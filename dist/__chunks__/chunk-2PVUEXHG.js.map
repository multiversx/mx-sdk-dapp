{
  "version": 3,
  "sources": ["../../src/utils/smartContracts.ts"],
  "sourcesContent": ["import { Address, TransactionPayload } from '@multiversx/sdk-core';\nimport { TypesOfSmartContractCallsEnum } from 'types';\nimport { addressIsValid } from './account/addressIsValid';\nimport { isStringBase64 } from './decoders/base64Utils';\n\nexport const ESDTTransferTypes = [\n  'ESDTNFTTransfer',\n  'ESDTNFTBurn',\n  'ESDTNFTAddQuantity',\n  'ESDTNFTCreate',\n  'MultiESDTNFTTransfer',\n  'ESDTTransfer',\n  'ESDTBurn',\n  'ESDTLocalMint',\n  'ESDTLocalBurn',\n  'ESDTWipe',\n  'ESDTFreeze'\n];\n\nexport function isContract(\n  receiver: string,\n  sender?: string,\n  data = ''\n): boolean {\n  const isValid = addressIsValid(receiver);\n\n  if (!isValid) {\n    return false;\n  }\n\n  const isContract = new Address(receiver).isContractAddress();\n\n  if (isContract) {\n    return true;\n  }\n\n  const extractedAddress = getAddressFromDataField({ receiver, data });\n\n  if (!extractedAddress) {\n    return false;\n  }\n\n  const isExtractedAddressContractCall = new Address(\n    extractedAddress\n  ).isContractAddress();\n\n  return (\n    isExtractedAddressContractCall || isSelfESDTContract(receiver, sender, data)\n  );\n}\n\nconst isHexValidCharacters = (str: string) => {\n  return str.toLowerCase().match(/[0-9a-f]/g);\n};\nconst isHexValidLength = (str: string) => {\n  return str.length % 2 === 0;\n};\n\nexport function isSelfESDTContract(\n  receiver: string,\n  sender?: string,\n  data?: string\n) {\n  const parts = data?.split('@');\n  if (parts == null) {\n    return false;\n  }\n  const [type, ...restParts] = parts;\n  const isSelfTransaction =\n    sender != null && receiver != null && receiver === sender;\n  const isCorrectESDTType = ESDTTransferTypes.includes(type);\n  const areDataPartsValid = restParts.every(\n    (part) => isHexValidCharacters(part) && isHexValidLength(part)\n  );\n  return isSelfTransaction && isCorrectESDTType && areDataPartsValid;\n}\n\nexport function getAddressFromDataField({\n  receiver,\n  data\n}: {\n  receiver: string;\n  data: string;\n}) {\n  try {\n    if (!data) {\n      return receiver;\n    }\n    const parsedData = isStringBase64(data)\n      ? TransactionPayload.fromEncoded(data).toString()\n      : data;\n\n    const addressIndex = getAddressIndex(parsedData);\n\n    const parts = parsedData.split('@');\n    return addressIndex > -1 ? parts[addressIndex] : receiver;\n  } catch (err) {\n    console.log(err);\n    return;\n  }\n}\n\nfunction getAddressIndex(data: string) {\n  if (data.includes(TypesOfSmartContractCallsEnum.MultiESDTNFTTransfer)) {\n    return 1;\n  }\n  if (data.includes(TypesOfSmartContractCallsEnum.ESDTNFTTransfer)) {\n    return 4;\n  }\n  return -1;\n}\n"],
  "mappings": "qLAAA,uEAmBO,WACL,EACA,EACA,EAAO,GACE,CAGT,GAAI,CAFY,EAAe,CAAQ,EAGrC,MAAO,GAKT,GAFmB,GAAI,GAAQ,CAAQ,EAAE,kBAAkB,EAGzD,MAAO,GAGT,GAAM,GAAmB,EAAwB,CAAE,WAAU,MAAK,CAAC,EAEnE,MAAK,GASH,AALqC,GAAI,GACzC,CACF,EAAE,kBAAkB,GAGgB,EAAmB,EAAU,EAAQ,CAAI,EARpE,EAUX,CASO,WACL,EACA,EACA,EACA,CACA,GAAM,GAAQ,iBAAM,MAAM,KAC1B,GAAI,GAAS,KACX,MAAO,GAET,GAAM,CAAC,KAAS,GAAa,EACvB,EACJ,GAAU,MAAQ,GAAY,MAAQ,IAAa,EAC/C,EAAoB,EAAkB,SAAS,CAAI,EACnD,EAAoB,EAAU,MAClC,AAAC,GAAS,EAAqB,CAAI,GAAK,EAAiB,CAAI,CAC/D,EACA,MAAO,IAAqB,GAAqB,CACnD,CAEO,WAAiC,CACtC,WACA,QAIC,CACD,GAAI,CACF,GAAI,CAAC,EACH,MAAO,GAET,GAAM,GAAa,EAAe,CAAI,EAClC,EAAmB,YAAY,CAAI,EAAE,SAAS,EAC9C,EAEE,EAAe,EAAgB,CAAU,EAEzC,EAAQ,EAAW,MAAM,GAAG,EAClC,MAAO,GAAe,GAAK,EAAM,GAAgB,CACnD,OAAS,EAAP,CACA,QAAQ,IAAI,CAAG,EACf,MACF,CACF,CAEA,WAAyB,EAAc,CACrC,MAAI,GAAK,SAAS,sBAAkD,EAC3D,EAEL,EAAK,SAAS,iBAA6C,EACtD,EAEF,EACT,CA9GA,GAKa,GA8CP,EAGA,EAtDN,aACA,IACA,IACA,IAEO,AAAM,EAAoB,CAC/B,kBACA,cACA,qBACA,gBACA,uBACA,eACA,WACA,gBACA,gBACA,WACA,YACF,EAkCA,AAAM,EAAuB,AAAC,GACrB,EAAI,YAAY,EAAE,MAAM,WAAW,EAEtC,EAAmB,AAAC,GACjB,EAAI,OAAS,IAAM",
  "names": []
}
