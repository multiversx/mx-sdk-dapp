{
  "version": 3,
  "sources": ["../../src/hooks/transactions/useCheckTransactionStatus/checkBatch.ts"],
  "sourcesContent": ["import { getTransactionsByHashes as defaultGetTxByHash } from 'apiCalls/transactions';\nimport { updateSignedTransactionStatus } from 'reduxStore/slices';\nimport { store } from 'reduxStore/store';\nimport {\n  CustomTransactionInformation,\n  GetTransactionsByHashesReturnType,\n  ServerTransactionType,\n  SignedTransactionsBodyType\n} from 'types';\nimport { TransactionServerStatusesEnum } from 'types/enums.types';\nimport { TransactionsTrackerType } from 'types/transactionsTracker.types';\nimport { refreshAccount } from 'utils/account';\nimport {\n  getIsTransactionFailed,\n  getIsTransactionPending,\n  getIsTransactionSuccessful\n} from 'utils/transactions';\nimport { getPendingTransactions } from './getPendingTransactions';\nimport { manageFailedTransactions } from './manageFailedTransactions';\nimport { manageTimedOutTransactions } from './manageTimedOutTransactions';\n\nexport interface TransactionStatusTrackerPropsType\n  extends TransactionsTrackerType {\n  sessionId: string;\n  transactionBatch: SignedTransactionsBodyType;\n  shouldRefreshBalance?: boolean;\n  isSequential?: boolean;\n}\n\ninterface RetriesType {\n  [hash: string]: number;\n}\n\nconst retries: RetriesType = {};\nconst timeouts: string[] = [];\n\ninterface ManageTransactionType {\n  serverTransaction: GetTransactionsByHashesReturnType[0];\n  sessionId: string;\n  customTransactionInformation?: CustomTransactionInformation;\n  shouldRefreshBalance?: boolean;\n  isSequential?: boolean;\n}\n\nfunction manageTransaction({\n  serverTransaction,\n  sessionId,\n  customTransactionInformation,\n  shouldRefreshBalance,\n  isSequential\n}: ManageTransactionType) {\n  const {\n    hash,\n    status,\n    inTransit,\n    results,\n    invalidTransaction,\n    hasStatusChanged\n  } = serverTransaction;\n  try {\n    if (timeouts.includes(hash)) {\n      return;\n    }\n\n    const retriesForThisHash = retries[hash];\n    if (retriesForThisHash > 30) {\n      // consider transaction as stuck after 1 minute\n      manageTimedOutTransactions(sessionId);\n      return;\n    }\n\n    if (\n      (invalidTransaction && !isSequential) ||\n      getIsTransactionPending(status)\n    ) {\n      retries[hash] = retries[hash] ? retries[hash] + 1 : 1;\n      return;\n    }\n\n    // The tx is from a sequential batch.\n    // If the transactions before this are not successful then it means that no other tx will be processed\n    if (isSequential && !status) {\n      store.dispatch(\n        updateSignedTransactionStatus({\n          sessionId,\n          status,\n          transactionHash: hash,\n          inTransit,\n          serverTransaction:\n            serverTransaction as unknown as ServerTransactionType\n        })\n      );\n      return;\n    }\n\n    if (hasStatusChanged) {\n      if (\n        getIsTransactionSuccessful(status) &&\n        customTransactionInformation?.completedTransactionsDelay != null\n      ) {\n        //if the transaction is successful and the success status should be updated with a delay\n        //it will enter a timeout and then change the status\n        timeouts.push(hash);\n        setTimeout(\n          () =>\n            store.dispatch(\n              updateSignedTransactionStatus({\n                sessionId,\n                status: TransactionServerStatusesEnum.success,\n                transactionHash: hash,\n                inTransit,\n                serverTransaction:\n                  serverTransaction as unknown as ServerTransactionType\n              })\n            ),\n          customTransactionInformation?.completedTransactionsDelay\n        );\n      } else {\n        //otherwise, it will just trigger the change of status\n        store.dispatch(\n          updateSignedTransactionStatus({\n            sessionId,\n            status,\n            transactionHash: hash,\n            inTransit,\n            serverTransaction:\n              serverTransaction as unknown as ServerTransactionType\n          })\n        );\n      }\n    }\n\n    // if set to true will trigger a balance refresh after each iteration\n    if (!shouldRefreshBalance) {\n      refreshAccount();\n    }\n\n    if (getIsTransactionFailed(status)) {\n      manageFailedTransactions({ sessionId, hash, results });\n    }\n  } catch (error) {\n    console.error(error);\n    manageTimedOutTransactions(sessionId);\n  }\n}\n\nexport async function checkBatch({\n  sessionId,\n  transactionBatch: { transactions, customTransactionInformation },\n  getTransactionsByHash = defaultGetTxByHash,\n  shouldRefreshBalance,\n  isSequential,\n  onSuccess,\n  onFail\n}: TransactionStatusTrackerPropsType) {\n  try {\n    if (transactions == null) {\n      return;\n    }\n\n    const pendingTransactions = getPendingTransactions(transactions, timeouts);\n\n    const serverTransactions = await getTransactionsByHash(pendingTransactions);\n\n    for (const serverTransaction of serverTransactions) {\n      manageTransaction({\n        serverTransaction,\n        sessionId,\n        customTransactionInformation,\n        shouldRefreshBalance,\n        isSequential\n      });\n    }\n\n    const hasCompleted = serverTransactions.every(\n      (tx) => tx.status !== TransactionServerStatusesEnum.pending\n    );\n\n    // Call the onSuccess or onFail callback only if the transactions are sent normally (not using batch transactions mechanism).\n    // The batch transactions mechanism will call the callbacks separately.\n    if (hasCompleted && !customTransactionInformation?.grouping) {\n      const isSuccessful = serverTransactions.every(\n        (tx) => tx.status === TransactionServerStatusesEnum.success\n      );\n\n      if (isSuccessful) {\n        return onSuccess?.(sessionId);\n      }\n\n      const isFailed = serverTransactions.some(\n        (tx) => tx.status === TransactionServerStatusesEnum.fail\n      );\n\n      if (isFailed) {\n        return onFail?.(sessionId);\n      }\n    }\n  } catch (error) {\n    console.error(error);\n  }\n}\n"],
  "mappings": "4fAAA,IACA,IACA,IAOA,IAGA,IAqBA,GAAM,GAAuB,CAAC,EACxB,EAAqB,CAAC,EAU5B,WAA2B,CACzB,oBACA,YACA,+BACA,uBACA,gBACwB,CACxB,GAAM,CACJ,OACA,SACA,YACA,UACA,qBACA,oBACE,EACJ,GAAI,CACF,GAAI,EAAS,SAAS,CAAI,EACxB,OAIF,GAAI,AADuB,EAAQ,GACV,GAAI,CAE3B,EAA2B,CAAS,EACpC,MACF,CAEA,GACG,GAAsB,CAAC,GACxB,EAAwB,CAAM,EAC9B,CACA,EAAQ,GAAQ,EAAQ,GAAQ,EAAQ,GAAQ,EAAI,EACpD,MACF,CAIA,GAAI,GAAgB,CAAC,EAAQ,CAC3B,EAAM,SACJ,EAA8B,CAC5B,YACA,SACA,gBAAiB,EACjB,YACA,kBACE,CACJ,CAAC,CACH,EACA,MACF,CAEA,AAAI,GACF,CACE,EAA2B,CAAM,GACjC,kBAA8B,6BAA8B,KAI5D,GAAS,KAAK,CAAI,EAClB,WACE,IACE,EAAM,SACJ,EAA8B,CAC5B,YACA,OAAQ,UACR,gBAAiB,EACjB,YACA,kBACE,CACJ,CAAC,CACH,EACF,iBAA8B,0BAChC,GAGA,EAAM,SACJ,EAA8B,CAC5B,YACA,SACA,gBAAiB,EACjB,YACA,kBACE,CACJ,CAAC,CACH,GAKC,GACH,EAAe,EAGb,EAAuB,CAAM,GAC/B,EAAyB,CAAE,YAAW,OAAM,SAAQ,CAAC,CAEzD,OAAS,EAAP,CACA,QAAQ,MAAM,CAAK,EACnB,EAA2B,CAAS,CACtC,CACF,CAEA,WAAiC,EAQK,mCARL,CAC/B,YACA,iBAAkB,CAAE,eAAc,gCAClC,wBAAwB,EACxB,uBACA,eACA,YACA,UACoC,CACpC,GAAI,CACF,GAAI,GAAgB,KAClB,OAGF,GAAM,GAAsB,EAAuB,EAAc,CAAQ,EAEnE,EAAqB,KAAM,GAAsB,CAAmB,EAE1E,OAAW,KAAqB,GAC9B,EAAkB,CAChB,oBACA,YACA,+BACA,uBACA,cACF,CAAC,EASH,GAAI,AANiB,EAAmB,MACtC,AAAC,GAAO,EAAG,SAAW,SACxB,GAIoB,CAAC,YAA8B,UAAU,CAK3D,GAJqB,EAAmB,MACtC,AAAC,GAAO,EAAG,SAAW,SACxB,EAGE,MAAO,kBAAY,GAOrB,GAJiB,EAAmB,KAClC,AAAC,GAAO,EAAG,SAAW,MACxB,EAGE,MAAO,kBAAS,EAEpB,CACF,OAAS,EAAP,CACA,QAAQ,MAAM,CAAK,CACrB,CACF",
  "names": []
}
