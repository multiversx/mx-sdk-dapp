{
  "version": 3,
  "sources": ["../../src/hooks/transactions/batch/tracker/useCheckBatchesOnWsFailureFallback.ts"],
  "sourcesContent": ["import { useCallback, useEffect, useRef } from 'react';\nimport { TRANSACTIONS_STATUS_POLLING_INTERVAL_MS } from 'constants/transactionStatus';\nimport {\n  websocketConnection,\n  WebsocketConnectionStatusEnum\n} from '../../../websocketListener/websocketConnection';\nimport { extractSessionId } from '../../helpers/extractSessionId';\nimport { timestampIsOlderThan } from '../../helpers/timestampIsOlderThan';\nimport { useGetPollingInterval } from '../../useGetPollingInterval';\nimport { useGetBatches } from '../useGetBatches';\nimport { useVerifyBatchStatus } from './useVerifyBatchStatus';\n\n/**\n * Fallback mechanism to check batches in case of ws connection failure\n * Resolves the toast by checking the status of each transaction in batch after a certain time (90seconds)\n * */\nexport const useCheckBatchesOnWsFailureFallback = (props?: {\n  onSuccess?: (sessionId: string | null) => void;\n  onFail?: (sessionId: string | null, errorMessage?: string) => void;\n}) => {\n  const { batchTransactionsArray } = useGetBatches();\n  const { verifyBatchStatus } = useVerifyBatchStatus(props);\n  const pollingInterval = useGetPollingInterval();\n  const pollingIntervalTimer = useRef<NodeJS.Timeout | null>(null);\n  const isWebsocketCompleted =\n    websocketConnection.status === WebsocketConnectionStatusEnum.COMPLETED;\n\n  const checkAllBatches = useCallback(async () => {\n    for (const { batchId } of batchTransactionsArray) {\n      const sessionId = extractSessionId(batchId);\n      if (!sessionId) {\n        continue;\n      }\n\n      if (\n        !timestampIsOlderThan(\n          sessionId,\n          TRANSACTIONS_STATUS_POLLING_INTERVAL_MS\n        )\n      ) {\n        continue;\n      }\n\n      await verifyBatchStatus({ batchId });\n    }\n  }, [batchTransactionsArray, verifyBatchStatus]);\n\n  useEffect(() => {\n    if (isWebsocketCompleted) {\n      // Do not setInterval if we already subscribe to websocket event\n      if (pollingIntervalTimer.current) {\n        clearInterval(pollingIntervalTimer.current);\n      }\n\n      return;\n    }\n\n    if (pollingIntervalTimer.current) {\n      return;\n    }\n\n    pollingIntervalTimer.current = setInterval(() => {\n      checkAllBatches();\n    }, pollingInterval);\n\n    return () => {\n      if (pollingIntervalTimer.current) {\n        clearInterval(pollingIntervalTimer.current);\n      }\n    };\n  }, [checkAllBatches]);\n};\n"],
  "mappings": "8UAAA,IACA,IADA,+DAgBO,GAAM,GAAqC,AAAC,GAG7C,CACJ,GAAM,CAAE,0BAA2B,EAAc,EAC3C,CAAE,qBAAsB,EAAqB,CAAK,EAClD,EAAkB,EAAsB,EACxC,EAAuB,EAA8B,IAAI,EACzD,EACJ,EAAoB,SAAW,YAE3B,EAAkB,EAAY,IAAY,0BAC9C,OAAW,CAAE,YAAa,GAAwB,CAChD,GAAM,GAAY,EAAiB,CAAO,EAC1C,AAAI,CAAC,GAKH,CAAC,EACC,EACA,GACF,GAKF,MAAM,GAAkB,CAAE,SAAQ,CAAC,EACrC,CACF,GAAG,CAAC,EAAwB,CAAiB,CAAC,EAE9C,EAAU,IAAM,CACd,GAAI,EAAsB,CAExB,AAAI,EAAqB,SACvB,cAAc,EAAqB,OAAO,EAG5C,MACF,CAEA,GAAI,GAAqB,QAIzB,SAAqB,QAAU,YAAY,IAAM,CAC/C,EAAgB,CAClB,EAAG,CAAe,EAEX,IAAM,CACX,AAAI,EAAqB,SACvB,cAAc,EAAqB,OAAO,CAE9C,CACF,EAAG,CAAC,CAAe,CAAC,CACtB",
  "names": []
}
