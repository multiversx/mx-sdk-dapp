{
  "version": 3,
  "sources": ["../../src/wrappers/AuthenticatedRoutesWrapper/helpers/matchPath.tsx"],
  "sourcesContent": ["// credits go to: https://remix.run\n// sourcecode: https://raw.githubusercontent.com/remix-run/react-router/6b44e99f0b659428ce2ec8d5098e90c7fddda2c5/packages/react-router/lib/router.ts\n\nfunction warning(cond: any, message: string): void {\n  if (!cond) {\n    // eslint-disable-next-line no-console\n    if (typeof console !== 'undefined') console.warn(message);\n\n    try {\n      // Welcome to debugging React Router!\n      //\n      // This error is thrown as a convenience so you can more easily\n      // find the source for a warning that appears in the console by\n      // enabling \"pause on exceptions\" in your JavaScript debugger.\n      throw new Error(message);\n      // eslint-disable-next-line no-empty\n    } catch (e) {}\n  }\n}\n\ntype ParamParseFailed = { failed: true };\n\ntype ParamParseSegment<Segment extends string> =\n  // Check here if there exists a forward slash in the string.\n  // eslint-disable-next-line prettier/prettier\n  Segment extends `${infer LeftSegment}/${infer RightSegment}`\n    ? // If there is a forward slash, then attempt to parse each side of the\n      // forward slash.\n      ParamParseSegment<LeftSegment> extends infer LeftResult\n      ? ParamParseSegment<RightSegment> extends infer RightResult\n        ? LeftResult extends string\n          ? // If the left side is successfully parsed as a param, then check if\n            // the right side can be successfully parsed as well. If both sides\n            // can be parsed, then the result is a union of the two sides\n            // (read: \"foo\" | \"bar\").\n            RightResult extends string\n            ? LeftResult | RightResult\n            : LeftResult\n          : // If the left side is not successfully parsed as a param, then check\n          // if only the right side can be successfully parse as a param. If it\n          // can, then the result is just right, else it's a failure.\n          RightResult extends string\n          ? RightResult\n          : ParamParseFailed\n        : ParamParseFailed\n      : // If the left side didn't parse into a param, then just check the right\n      // side.\n      ParamParseSegment<RightSegment> extends infer RightResult\n      ? RightResult extends string\n        ? RightResult\n        : ParamParseFailed\n      : ParamParseFailed\n    : // If there's no forward slash, then check if this segment starts with a\n    // colon. If it does, then this is a dynamic segment, so the result is\n    // just the remainder of the string. Otherwise, it's a failure.\n    Segment extends `:${infer Remaining}`\n    ? Remaining\n    : ParamParseFailed;\n\n// Attempt to parse the given string segment. If it fails, then just return the\n// plain string type as a default fallback. Otherwise return the union of the\n// parsed string literals that were referenced as dynamic segments in the route.\ntype ParamParseKey<Segment extends string> =\n  ParamParseSegment<Segment> extends string\n    ? ParamParseSegment<Segment>\n    : string;\n\n/**\n * The parameters that were parsed from the URL path.\n */\ntype Params<Key extends string = string> = {\n  readonly [key in Key]: string | undefined;\n};\n\n/**\n * A PathPattern is used to match on some portion of a URL pathname.\n */\ninterface PathPattern<Path extends string = string> {\n  /**\n   * A string to match against a URL pathname. May contain `:id`-style segments\n   * to indicate placeholders for dynamic parameters. May also end with `/*` to\n   * indicate matching the rest of the URL pathname.\n   */\n  path: Path;\n  /**\n   * Should be `true` if the static portions of the `path` should be matched in\n   * the same case.\n   */\n  caseSensitive?: boolean;\n  /**\n   * Should be `true` if this pattern should match the entire URL pathname.\n   */\n  end?: boolean;\n}\n\n/**\n * A PathMatch contains info about how a PathPattern matched on a URL pathname.\n */\ninterface PathMatch<ParamKey extends string = string> {\n  /**\n   * The names and values of dynamic parameters in the URL.\n   */\n  params: Params<ParamKey>;\n  /**\n   * The portion of the URL pathname that was matched.\n   */\n  pathname: string;\n  /**\n   * The portion of the URL pathname that was matched before child routes.\n   */\n  pathnameBase: string;\n  /**\n   * The pattern that was used to match.\n   */\n  pattern: PathPattern;\n}\n\ntype Mutable<T> = {\n  -readonly [P in keyof T]: T[P];\n};\n\n/**\n * Performs pattern matching on a URL pathname and returns information about\n * the match.\n *\n * @see https://reactrouter.com/docs/en/v6/utils/match-path\n */\nexport function matchPath<\n  ParamKey extends ParamParseKey<Path>,\n  Path extends string\n>(\n  pattern: PathPattern<Path> | Path,\n  pathname: string\n): PathMatch<ParamKey> | null {\n  if (typeof pattern === 'string') {\n    pattern = { path: pattern, caseSensitive: false, end: true };\n  }\n\n  const [matcher, paramNames] = compilePath(\n    pattern.path,\n    pattern.caseSensitive,\n    pattern.end\n  );\n\n  const match = pathname.match(matcher);\n  if (!match) return null;\n\n  const matchedPathname = match[0];\n  let pathnameBase = matchedPathname.replace(/(.)\\/+$/, '$1');\n  const captureGroups = match.slice(1);\n  const params: Params = paramNames.reduce<Mutable<Params>>(\n    (memo, paramName, index) => {\n      // We need to compute the pathnameBase here using the raw splat value\n      // instead of using params[\"*\"] later because it will be decoded then\n      if (paramName === '*') {\n        const splatValue = captureGroups[index] || '';\n        pathnameBase = matchedPathname\n          .slice(0, matchedPathname.length - splatValue.length)\n          .replace(/(.)\\/+$/, '$1');\n      }\n\n      memo[paramName] = safelyDecodeURIComponent(\n        captureGroups[index] || '',\n        paramName\n      );\n      return memo;\n    },\n    {}\n  );\n\n  return {\n    params,\n    pathname: matchedPathname,\n    pathnameBase,\n    pattern\n  };\n}\n\nfunction compilePath(\n  path: string,\n  caseSensitive = false,\n  end = true\n): [RegExp, string[]] {\n  warning(\n    path === '*' || !path.endsWith('*') || path.endsWith('/*'),\n    `Route path \"${path}\" will be treated as if it were ` +\n      `\"${path.replace(/\\*$/, '/*')}\" because the \\`*\\` character must ` +\n      'always follow a `/` in the pattern. To get rid of this warning, ' +\n      `please change the route path to \"${path.replace(/\\*$/, '/*')}\".`\n  );\n\n  const paramNames: string[] = [];\n  let regexpSource =\n    '^' +\n    path\n      .replace(/\\/*\\*?$/, '') // Ignore trailing / and /*, we'll handle it below\n      .replace(/^\\/*/, '/') // Make sure it has a leading /\n      .replace(/[\\\\.*+^$?{}|()[\\]]/g, '\\\\$&') // Escape special regex chars\n      .replace(/:(\\w+)/g, (_: string, paramName: string) => {\n        paramNames.push(paramName);\n        return '([^\\\\/]+)';\n      });\n\n  if (path.endsWith('*')) {\n    paramNames.push('*');\n    regexpSource +=\n      path === '*' || path === '/*'\n        ? '(.*)$' // Already matched the initial /, just match the rest\n        : '(?:\\\\/(.+)|\\\\/*)$'; // Don't include the / in params[\"*\"]\n  } else {\n    regexpSource += end\n      ? '\\\\/*$' // When matching to the end, ignore trailing slashes\n      : // Otherwise, match a word boundary or a proceeding /. The word boundary restricts\n        // parent routes to matching only their own words and nothing more, e.g. parent\n        // route \"/home\" should not match \"/home2\".\n        // Additionally, allow paths starting with `.`, `-`, `~`, and url-encoded entities,\n        // but do not consume the character in the matched path so they can match against\n        // nested paths.\n        '(?:(?=[.~-]|%[0-9A-F]{2})|\\\\b|\\\\/|$)';\n  }\n\n  const matcher = new RegExp(regexpSource, caseSensitive ? undefined : 'i');\n\n  return [matcher, paramNames];\n}\n\nfunction safelyDecodeURIComponent(value: string, paramName: string) {\n  try {\n    return decodeURIComponent(value);\n  } catch (error) {\n    warning(\n      false,\n      `The value for the URL param \"${paramName}\" will not be decoded because` +\n        ` the string \"${value}\" is a malformed URL segment. This is probably` +\n        ` due to a bad percent encoding (${error}).`\n    );\n\n    return value;\n  }\n}\n"],
  "mappings": "wCAAA,IAGA,WAAiB,EAAW,EAAuB,CACjD,GAAI,CAAC,EAAM,CAET,AAAI,MAAO,UAAY,aAAa,QAAQ,KAAK,CAAO,EAExD,GAAI,CAMF,KAAM,IAAI,OAAM,CAAO,CAEzB,OAAS,EAAP,CAAW,CACf,CACF,CA6GO,WAIL,EACA,EAC4B,CAC5B,AAAI,MAAO,IAAY,UACrB,GAAU,CAAE,KAAM,EAAS,cAAe,GAAO,IAAK,EAAK,GAG7D,GAAM,CAAC,EAAS,GAAc,EAC5B,EAAQ,KACR,EAAQ,cACR,EAAQ,GACV,EAEM,EAAQ,EAAS,MAAM,CAAO,EACpC,GAAI,CAAC,EAAO,MAAO,MAEnB,GAAM,GAAkB,EAAM,GAC1B,EAAe,EAAgB,QAAQ,UAAW,IAAI,EACpD,EAAgB,EAAM,MAAM,CAAC,EAqBnC,MAAO,CACL,OArBqB,EAAW,OAChC,CAAC,EAAM,EAAW,IAAU,CAG1B,GAAI,IAAc,IAAK,CACrB,GAAM,GAAa,EAAc,IAAU,GAC3C,EAAe,EACZ,MAAM,EAAG,EAAgB,OAAS,EAAW,MAAM,EACnD,QAAQ,UAAW,IAAI,CAC5B,CAEA,SAAK,GAAa,EAChB,EAAc,IAAU,GACxB,CACF,EACO,CACT,EACA,CAAC,CACH,EAIE,SAAU,EACV,eACA,SACF,CACF,CAEA,WACE,EACA,EAAgB,GAChB,EAAM,GACc,CACpB,EACE,IAAS,KAAO,CAAC,EAAK,SAAS,GAAG,GAAK,EAAK,SAAS,IAAI,EACzD,eAAe,qCACT,EAAK,QAAQ,MAAO,IAAI,0IAEQ,EAAK,QAAQ,MAAO,IAAI,KAChE,EAEA,GAAM,GAAuB,CAAC,EAC1B,EACF,IACA,EACG,QAAQ,UAAW,EAAE,EACrB,QAAQ,OAAQ,GAAG,EACnB,QAAQ,sBAAuB,MAAM,EACrC,QAAQ,UAAW,CAAC,EAAW,IAC9B,GAAW,KAAK,CAAS,EAClB,YACR,EAEL,MAAI,GAAK,SAAS,GAAG,EACnB,GAAW,KAAK,GAAG,EACnB,GACE,IAAS,KAAO,IAAS,KACrB,QACA,qBAEN,GAAgB,EACZ,QAOA,uCAKC,CAFS,GAAI,QAAO,EAAc,EAAgB,OAAY,GAAG,EAEvD,CAAU,CAC7B,CAEA,WAAkC,EAAe,EAAmB,CAClE,GAAI,CACF,MAAO,oBAAmB,CAAK,CACjC,OAAS,EAAP,CACA,SACE,GACA,gCAAgC,8CACd,kFACmB,KACvC,EAEO,CACT,CACF",
  "names": []
}
