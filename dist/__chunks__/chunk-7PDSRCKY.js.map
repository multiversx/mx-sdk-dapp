{
  "version": 3,
  "sources": ["../../src/hooks/transactions/batch/tracker/useVerifyBatchStatus.ts"],
  "sourcesContent": ["import { useCallback } from 'react';\nimport { useResolveBatchStatusResponse } from 'hooks/transactions/batch/useResolveBatchStatusResponse';\nimport { extractSessionId } from 'hooks/transactions/helpers/extractSessionId';\nimport { useGetSignedTransactions } from 'hooks/transactions/useGetSignedTransactions';\nimport { useDispatch } from 'reduxStore/DappProviderContext';\nimport { getTransactionsStatus } from 'utils/transactions/batch/getTransactionsStatus';\nimport { useCheckBatch } from './useCheckBatch';\nimport { useUpdateBatch } from './useUpdateBatch';\n\nexport const useVerifyBatchStatus = (props?: {\n  onSuccess?: (sessionId: string | null) => void;\n  onFail?: (sessionId: string | null, errorMessage?: string) => void;\n}) => {\n  const dispatch = useDispatch();\n  const { signedTransactions } = useGetSignedTransactions();\n\n  const checkBatch = useCheckBatch();\n  const updateBatch = useUpdateBatch();\n  const resolveBatchStatusResponse = useResolveBatchStatusResponse();\n\n  const onSuccess = props?.onSuccess;\n  const onFail = props?.onFail;\n\n  const verifyBatchStatus = useCallback(\n    async ({ batchId }: { batchId: string }) => {\n      const sessionId = extractSessionId(batchId)?.toString() ?? '';\n      const session = signedTransactions[sessionId];\n\n      if (!session) {\n        return;\n      }\n\n      // If the grouping is missing then means the transactions were sent with the normal flow\n      const grouping = session.customTransactionInformation?.grouping;\n      if (!grouping) {\n        return;\n      }\n\n      const sessionTransactions =\n        signedTransactions[sessionId]?.transactions ?? [];\n\n      const { isSuccessful, isFailed, isPending } = getTransactionsStatus({\n        transactions: sessionTransactions\n      });\n      const completed = !isPending;\n\n      if (completed) {\n        if (isSuccessful) {\n          onSuccess?.(sessionId);\n        }\n\n        if (isFailed) {\n          onFail?.(sessionId, 'Error processing batch transactions.');\n        }\n      } else {\n        const data = await checkBatch({ batchId });\n        await updateBatch({\n          sessionId: sessionId.toString(),\n          isBatchFailed: data?.isBatchFailed,\n          shouldRefreshBalance: true,\n          transactions: sessionTransactions\n        });\n      }\n    },\n    [\n      dispatch,\n      resolveBatchStatusResponse,\n      updateBatch,\n      signedTransactions,\n      checkBatch,\n      onSuccess,\n      onFail\n    ]\n  );\n\n  return { verifyBatchStatus };\n};\n"],
  "mappings": "uUAAA,wCASO,GAAM,GAAuB,AAAC,GAG/B,CACJ,GAAM,GAAW,EAAY,EACvB,CAAE,sBAAuB,EAAyB,EAElD,EAAa,EAAc,EAC3B,EAAc,EAAe,EAC7B,EAA6B,EAA8B,EAE3D,EAAY,iBAAO,UACnB,EAAS,iBAAO,OAsDtB,MAAO,CAAE,kBApDiB,EACxB,AAAO,GAAqC,UAArC,GAAqC,UAArC,CAAE,WAAmC,CAxBhD,cAyBM,GAAM,GAAY,QAAiB,CAAO,IAAxB,cAA2B,aAA3B,OAAyC,GACrD,EAAU,EAAmB,GAQnC,GANI,CAAC,GAMD,CADa,MAAQ,+BAAR,cAAsC,UAErD,OAGF,GAAM,GACJ,QAAmB,KAAnB,cAA+B,eAA/B,OAA+C,CAAC,EAE5C,CAAE,eAAc,WAAU,aAAc,EAAsB,CAClE,aAAc,CAChB,CAAC,EAGD,GAFkB,CAAC,EAGjB,AAAI,GACF,YAAY,IAGV,GACF,YAAS,EAAW,6CAEjB,CACL,GAAM,GAAO,KAAM,GAAW,CAAE,SAAQ,CAAC,EACzC,KAAM,GAAY,CAChB,UAAW,EAAU,SAAS,EAC9B,cAAe,iBAAM,cACrB,qBAAsB,GACtB,aAAc,CAChB,CAAC,CACH,CACF,GACA,CACE,EACA,EACA,EACA,EACA,EACA,EACA,CACF,CACF,CAE2B,CAC7B",
  "names": []
}
