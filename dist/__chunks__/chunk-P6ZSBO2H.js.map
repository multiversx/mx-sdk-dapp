{
  "version": 3,
  "sources": ["../../src/reduxStore/slices/accountInfoSlice.ts"],
  "sourcesContent": ["import { Address } from '@multiversx/sdk-core';\nimport { createSlice, PayloadAction } from '@reduxjs/toolkit';\nimport { REHYDRATE } from 'redux-persist';\nimport { ZERO } from 'constants/index';\nimport { BatchTransactionsWSResponseType } from 'types';\nimport { AccountType } from 'types/account.types';\nimport { storage } from 'utils/storage';\nimport { localStorageKeys } from 'utils/storage/local';\n\nimport {\n  loginAction,\n  logoutAction,\n  LoginActionPayloadType\n} from '../commonActions';\n\nexport interface LedgerAccountType {\n  index: number;\n  address: string;\n  hasContractDataEnabled: boolean;\n  version: string;\n}\n\nexport interface UpdateLedgerAccountPayloadType {\n  index: number;\n  address: string;\n}\n\nexport interface AccountInfoSliceType {\n  address: string;\n  shard?: number;\n  accounts: { [address: string]: AccountType };\n  publicKey: string;\n  ledgerAccount: LedgerAccountType | null;\n  walletConnectAccount: string | null;\n  isAccountLoading: boolean;\n  websocketEvent: {\n    timestamp: number;\n    message: string;\n  } | null;\n  websocketBatchEvent: {\n    timestamp: number;\n    data: BatchTransactionsWSResponseType;\n  } | null;\n  accountLoadingError: string | null;\n}\n\nexport const emptyAccount: AccountType = {\n  balance: '...',\n  address: '',\n  isGuarded: false,\n  nonce: 0,\n  txCount: 0,\n  scrCount: 0,\n  claimableRewards: ZERO\n};\n\nconst initialState: AccountInfoSliceType = {\n  address: '',\n  websocketEvent: null,\n  websocketBatchEvent: null,\n  accounts: { '': emptyAccount },\n  ledgerAccount: null,\n  publicKey: '',\n  walletConnectAccount: null,\n  isAccountLoading: true,\n  accountLoadingError: null\n};\n\nexport const accountInfoSlice = createSlice({\n  name: 'accountInfoSlice',\n  initialState: initialState,\n  reducers: {\n    setAddress: (\n      state: AccountInfoSliceType,\n      action: PayloadAction<string>\n    ) => {\n      const address = action.payload;\n      state.address = address;\n      state.publicKey = address ? new Address(address).hex() : '';\n    },\n    setAccount: (\n      state: AccountInfoSliceType,\n      action: PayloadAction<AccountType>\n    ) => {\n      // account fetching always comes after address is populated\n      const isSameAddress = state.address === action.payload.address;\n\n      state.accounts = {\n        [state.address]: isSameAddress ? action.payload : emptyAccount\n      };\n\n      state.shard = action.payload.shard;\n      state.isAccountLoading = false;\n      state.accountLoadingError = null;\n    },\n    setAccountNonce: (\n      state: AccountInfoSliceType,\n      action: PayloadAction<number>\n    ) => {\n      const { address } = state;\n      state.accounts[address].nonce = action.payload;\n    },\n    setAccountShard: (\n      state: AccountInfoSliceType,\n      action: PayloadAction<number>\n    ) => {\n      state.shard = action.payload;\n    },\n    setLedgerAccount: (\n      state: AccountInfoSliceType,\n      action: PayloadAction<LedgerAccountType | null>\n    ) => {\n      state.ledgerAccount = action.payload;\n    },\n    updateLedgerAccount: (\n      state: AccountInfoSliceType,\n      action: PayloadAction<UpdateLedgerAccountPayloadType>\n    ) => {\n      if (state.ledgerAccount != null) {\n        state.ledgerAccount.index = action.payload.index;\n        state.ledgerAccount.address = action.payload.address;\n      }\n    },\n    setWalletConnectAccount: (\n      state: AccountInfoSliceType,\n      action: PayloadAction<string | null>\n    ) => {\n      state.walletConnectAccount = action.payload;\n    },\n    setIsAccountLoading: (\n      state: AccountInfoSliceType,\n      action: PayloadAction<boolean>\n    ) => {\n      state.isAccountLoading = action.payload;\n      state.accountLoadingError = null;\n    },\n    setAccountLoadingError: (\n      state: AccountInfoSliceType,\n      action: PayloadAction<string | null>\n    ) => {\n      state.accountLoadingError = action.payload;\n      state.isAccountLoading = false;\n    },\n    setWebsocketEvent: (\n      state: AccountInfoSliceType,\n      action: PayloadAction<string>\n    ) => {\n      state.websocketEvent = {\n        timestamp: Date.now(),\n        message: action.payload\n      };\n    },\n    setWebsocketBatchEvent: (\n      state: AccountInfoSliceType,\n      action: PayloadAction<BatchTransactionsWSResponseType>\n    ) => {\n      state.websocketBatchEvent = {\n        timestamp: Date.now(),\n        data: action.payload\n      };\n    }\n  },\n  extraReducers: (builder) => {\n    builder.addCase(logoutAction, () => {\n      storage.local.removeItem(localStorageKeys.loginExpiresAt);\n      return initialState;\n    });\n    builder.addCase(\n      loginAction,\n      (\n        state: AccountInfoSliceType,\n        action: PayloadAction<LoginActionPayloadType>\n      ) => {\n        const { address } = action.payload;\n        state.address = address;\n        state.publicKey = new Address(address).hex();\n      }\n    );\n    builder.addCase(REHYDRATE, (state, action: any) => {\n      if (!action.payload?.account) {\n        return;\n      }\n\n      const { account: accountInfo } = action.payload;\n      const { address, shard, accounts, publicKey } =\n        accountInfo as AccountInfoSliceType;\n      state.address = address;\n      state.shard = shard;\n      const isAddressInAccounts = accounts && address in accounts;\n      state.accounts = isAddressInAccounts ? accounts : initialState.accounts;\n      state.publicKey = publicKey;\n    });\n  }\n});\n\nexport const {\n  setAccount,\n  setAddress,\n  setAccountNonce,\n  setAccountShard,\n  setLedgerAccount,\n  updateLedgerAccount,\n  setWalletConnectAccount,\n  setIsAccountLoading,\n  setAccountLoadingError,\n  setWebsocketEvent,\n  setWebsocketBatchEvent\n} = accountInfoSlice.actions;\n\nexport default accountInfoSlice.reducer;\n"],
  "mappings": "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",
  "names": []
}
