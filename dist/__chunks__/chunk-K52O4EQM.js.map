{
  "version": 3,
  "sources": ["../../src/hooks/transactions/useSignMultipleTransactions.tsx"],
  "sourcesContent": ["import { useEffect, useState } from 'react';\nimport {\n  Address,\n  Transaction,\n  TransactionOptions,\n  TransactionVersion\n} from '@multiversx/sdk-core';\n\nimport { useGetAccountFromApi } from 'apiCalls/accounts/useGetAccountFromApi';\nimport { SENDER_DIFFERENT_THAN_LOGGED_IN_ADDRESS } from 'constants/index';\nimport { useParseMultiEsdtTransferData } from 'hooks/transactions/useParseMultiEsdtTransferData';\nimport {\n  ActiveLedgerTransactionType,\n  DeviceSignedTransactions,\n  Nullable,\n  ScamInfoType\n} from 'types';\nimport { getLedgerErrorCodes } from 'utils/internal/getLedgerErrorCodes';\nimport { isTokenTransfer } from 'utils/transactions/isTokenTransfer';\nimport {\n  checkIsValidSender,\n  getAreAllTransactionsSignedByGuardian\n} from './helpers';\nimport { UseSignTransactionsWithDeviceReturnType } from './useSignTransactionsWithDevice';\n\nexport interface UseSignMultipleTransactionsPropsType {\n  egldLabel: string;\n  address: string;\n  activeGuardianAddress?: string;\n  hasGuardianScreen?: boolean;\n  verifyReceiverScam?: boolean;\n  isLedger?: boolean;\n  transactionsToSign?: Transaction[];\n  onCancel?: () => void;\n  onSignTransaction: (\n    transaction: Nullable<Transaction>\n  ) => Promise<Nullable<Transaction | undefined>>;\n  onTransactionsSignSuccess: (transactions: Transaction[]) => void;\n  onTransactionsSignError: (errorMessage: string) => void;\n  onGetScamAddressData?:\n    | ((address: string) => Promise<{ scamInfo?: ScamInfoType }>)\n    | null;\n}\n\ninterface VerifiedAddressesType {\n  [address: string]: { type: string; info: string };\n}\nlet verifiedAddresses: VerifiedAddressesType = {};\n\nexport interface UseSignMultipleTransactionsReturnType\n  extends Omit<UseSignTransactionsWithDeviceReturnType, 'callbackRoute'> {\n  shouldContinueWithoutSigning: boolean;\n  isFirstTransaction: boolean;\n  hasMultipleTransactions: boolean;\n}\n\nexport const useSignMultipleTransactions = ({\n  isLedger = false,\n  transactionsToSign,\n  egldLabel,\n  address,\n  activeGuardianAddress,\n  hasGuardianScreen,\n  onCancel,\n  onSignTransaction,\n  onTransactionsSignError,\n  onTransactionsSignSuccess,\n  onGetScamAddressData\n}: UseSignMultipleTransactionsPropsType): UseSignMultipleTransactionsReturnType => {\n  const isGuarded = Boolean(activeGuardianAddress);\n  const [currentStep, setCurrentStep] = useState(0);\n  const [signedTransactions, setSignedTransactions] =\n    useState<DeviceSignedTransactions>();\n  const [currentTransaction, setCurrentTransaction] =\n    useState<ActiveLedgerTransactionType | null>(null);\n\n  const [waitingForDevice, setWaitingForDevice] = useState(false);\n\n  const { getTxInfoByDataField, allTransactions } =\n    useParseMultiEsdtTransferData({\n      transactions: activeGuardianAddress\n        ? transactionsToSign?.map((transaction) => {\n            transaction.setSender(Address.fromBech32(address));\n            transaction.setVersion(TransactionVersion.withTxOptions());\n            transaction.setGuardian(Address.fromBech32(activeGuardianAddress));\n            const options = {\n              guarded: true,\n              ...(isLedger ? { hashSign: true } : {})\n            };\n            transaction.setOptions(TransactionOptions.withOptions(options));\n            return transaction;\n          })\n        : transactionsToSign\n    });\n\n  const isLastTransaction = currentStep === allTransactions.length - 1;\n  const currentTx = allTransactions[currentStep];\n  const sender = currentTransaction?.transaction?.getSender().toString();\n\n  // Skip account fetching if the sender is missing or same as current account\n  const { data: senderAccount } = useGetAccountFromApi(\n    !sender || sender === address ? null : sender\n  );\n\n  const extractTransactionsInfo = async () => {\n    if (currentTx == null) {\n      return;\n    }\n\n    const { transaction, multiTxData, transactionIndex } = currentTx;\n    const dataField = transaction.getData().toString();\n    const transactionTokenInfo = getTxInfoByDataField(\n      transaction.getData().toString(),\n      multiTxData\n    );\n\n    const { tokenId } = transactionTokenInfo;\n    const receiver = transaction.getReceiver().toString();\n\n    if (sender && sender !== address) {\n      const isValidSender = checkIsValidSender(senderAccount, address);\n\n      if (!isValidSender) {\n        console.error(SENDER_DIFFERENT_THAN_LOGGED_IN_ADDRESS);\n\n        return onCancel?.();\n      }\n    }\n\n    const notSender = address !== receiver;\n    const verified = receiver in verifiedAddresses;\n\n    if (receiver && notSender && !verified && onGetScamAddressData != null) {\n      const data = await onGetScamAddressData(receiver);\n      verifiedAddresses = {\n        ...verifiedAddresses,\n        ...(data?.scamInfo ? { [receiver]: data.scamInfo } : {})\n      };\n    }\n\n    const isTokenTransaction = Boolean(\n      tokenId && isTokenTransfer({ tokenId, erdLabel: egldLabel })\n    );\n\n    setCurrentTransaction({\n      transaction,\n      receiverScamInfo: verifiedAddresses[receiver]?.info || null,\n      transactionTokenInfo,\n      isTokenTransaction,\n      dataField,\n      transactionIndex\n    });\n  };\n\n  useEffect(() => {\n    extractTransactionsInfo();\n  }, [currentTx, senderAccount]);\n\n  const reset = () => {\n    setCurrentStep(0);\n    setSignedTransactions(undefined);\n    setWaitingForDevice(false);\n  };\n\n  const sign = async () => {\n    const existingSignedTransactions = Object.values(signedTransactions ?? {});\n\n    const alreadySignedByGuardian = getAreAllTransactionsSignedByGuardian({\n      isGuarded,\n      transactions: existingSignedTransactions\n    });\n\n    if (isGuarded && alreadySignedByGuardian) {\n      onTransactionsSignSuccess(existingSignedTransactions);\n      reset();\n      return;\n    }\n\n    if (currentTransaction == null) {\n      return;\n    }\n\n    setWaitingForDevice(isLedger);\n\n    let signedTx: Nullable<Transaction | undefined>;\n\n    try {\n      signedTx = await onSignTransaction(currentTransaction.transaction);\n    } catch (err) {\n      console.error(err, 'sign error');\n      const { message } = err as any;\n      const errorMessage = isLedger\n        ? getLedgerErrorCodes(err).errorMessage\n        : null;\n\n      reset();\n      onTransactionsSignError(errorMessage ?? message);\n      return;\n    }\n\n    if (!signedTx) {\n      return;\n    }\n\n    const newSignedTx = { [currentStep]: signedTx };\n    const newSignedTransactions = signedTransactions\n      ? { ...signedTransactions, ...newSignedTx }\n      : newSignedTx;\n\n    setSignedTransactions(newSignedTransactions);\n\n    if (!isLastTransaction) {\n      setCurrentStep((exising) => exising + 1);\n      setWaitingForDevice(false);\n      return;\n    }\n\n    if (!newSignedTransactions) {\n      return;\n    }\n\n    const allSignedTransactions = Object.values(newSignedTransactions);\n\n    const allSignedByGuardian = getAreAllTransactionsSignedByGuardian({\n      isGuarded,\n      transactions: allSignedTransactions\n    });\n\n    if (!allSignedByGuardian && hasGuardianScreen) {\n      return;\n    }\n\n    onTransactionsSignSuccess(allSignedTransactions);\n    reset();\n  };\n\n  const signTx = async () => {\n    try {\n      if (currentTransaction == null) {\n        return;\n      }\n\n      const signature = currentTransaction.transaction.getSignature();\n\n      if (signature.toString('hex') && !isLastTransaction) {\n        setCurrentStep((exising) => exising + 1);\n        return;\n      }\n\n      await sign();\n    } catch (e) {\n      console.error('Error during signing transaction');\n      // the only way to check if tx has signature is with try catch\n      await sign();\n    }\n  };\n\n  const isFirst = currentStep === 0;\n\n  const handleAbort = () => {\n    if (isFirst) {\n      onCancel?.();\n    } else {\n      setCurrentStep((existing) => existing - 1);\n    }\n  };\n\n  const shouldContinueWithoutSigning = Boolean(\n    currentTransaction?.transactionTokenInfo?.type &&\n      currentTransaction?.transactionTokenInfo?.multiTxData &&\n      !currentTransaction?.dataField.endsWith(\n        currentTransaction?.transactionTokenInfo?.multiTxData\n      )\n  );\n\n  const handleSignTransaction = async () => {\n    if (shouldContinueWithoutSigning) {\n      setCurrentStep((exising) => exising + 1);\n      return;\n    }\n\n    await signTx();\n  };\n\n  const onNext = () => {\n    setCurrentStep((current) => {\n      const nextStep = current + 1;\n\n      if (nextStep > allTransactions?.length) {\n        return current;\n      }\n\n      return nextStep;\n    });\n  };\n\n  const onPrev = () => {\n    setCurrentStep((current) => {\n      const nextStep = current - 1;\n\n      if (nextStep < 0) {\n        return current;\n      }\n\n      return nextStep;\n    });\n  };\n\n  return {\n    allTransactions,\n    onSignTransaction: handleSignTransaction,\n    onNext,\n    onPrev,\n    waitingForDevice,\n    onAbort: handleAbort,\n    isLastTransaction,\n    isFirstTransaction: currentStep === 0,\n    hasMultipleTransactions: allTransactions.length > 1,\n    shouldContinueWithoutSigning,\n    currentStep,\n    signedTransactions,\n    setSignedTransactions,\n    currentTransaction\n  };\n};\n"],
  "mappings": "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",
  "names": []
}
