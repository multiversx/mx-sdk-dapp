{
  "version": 3,
  "sources": ["../../node_modules/lodash/_baseInRange.js", "../../node_modules/lodash/_trimmedEndIndex.js", "../../node_modules/lodash/_baseTrim.js", "../../node_modules/lodash/toNumber.js", "../../node_modules/lodash/toFinite.js", "../../node_modules/lodash/inRange.js", "../../node_modules/lodash/_baseRange.js", "../../node_modules/lodash/isLength.js", "../../node_modules/lodash/isArrayLike.js", "../../node_modules/lodash/_isIndex.js", "../../node_modules/lodash/_isIterateeCall.js", "../../node_modules/lodash/_createRange.js", "../../node_modules/lodash/range.js", "../../src/UI/Pagination/helpers/getPagination/getPagination.ts"],
  "sourcesContent": ["/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max,\n    nativeMin = Math.min;\n\n/**\n * The base implementation of `_.inRange` which doesn't coerce arguments.\n *\n * @private\n * @param {number} number The number to check.\n * @param {number} start The start of the range.\n * @param {number} end The end of the range.\n * @returns {boolean} Returns `true` if `number` is in the range, else `false`.\n */\nfunction baseInRange(number, start, end) {\n  return number >= nativeMin(start, end) && number < nativeMax(start, end);\n}\n\nmodule.exports = baseInRange;\n", "/** Used to match a single whitespace character. */\nvar reWhitespace = /\\s/;\n\n/**\n * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace\n * character of `string`.\n *\n * @private\n * @param {string} string The string to inspect.\n * @returns {number} Returns the index of the last non-whitespace character.\n */\nfunction trimmedEndIndex(string) {\n  var index = string.length;\n\n  while (index-- && reWhitespace.test(string.charAt(index))) {}\n  return index;\n}\n\nmodule.exports = trimmedEndIndex;\n", "var trimmedEndIndex = require('./_trimmedEndIndex');\n\n/** Used to match leading whitespace. */\nvar reTrimStart = /^\\s+/;\n\n/**\n * The base implementation of `_.trim`.\n *\n * @private\n * @param {string} string The string to trim.\n * @returns {string} Returns the trimmed string.\n */\nfunction baseTrim(string) {\n  return string\n    ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '')\n    : string;\n}\n\nmodule.exports = baseTrim;\n", "var baseTrim = require('./_baseTrim'),\n    isObject = require('./isObject'),\n    isSymbol = require('./isSymbol');\n\n/** Used as references for various `Number` constants. */\nvar NAN = 0 / 0;\n\n/** Used to detect bad signed hexadecimal string values. */\nvar reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\n/** Used to detect binary string values. */\nvar reIsBinary = /^0b[01]+$/i;\n\n/** Used to detect octal string values. */\nvar reIsOctal = /^0o[0-7]+$/i;\n\n/** Built-in method references without a dependency on `root`. */\nvar freeParseInt = parseInt;\n\n/**\n * Converts `value` to a number.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {number} Returns the number.\n * @example\n *\n * _.toNumber(3.2);\n * // => 3.2\n *\n * _.toNumber(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toNumber(Infinity);\n * // => Infinity\n *\n * _.toNumber('3.2');\n * // => 3.2\n */\nfunction toNumber(value) {\n  if (typeof value == 'number') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return NAN;\n  }\n  if (isObject(value)) {\n    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n    value = isObject(other) ? (other + '') : other;\n  }\n  if (typeof value != 'string') {\n    return value === 0 ? value : +value;\n  }\n  value = baseTrim(value);\n  var isBinary = reIsBinary.test(value);\n  return (isBinary || reIsOctal.test(value))\n    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n    : (reIsBadHex.test(value) ? NAN : +value);\n}\n\nmodule.exports = toNumber;\n", "var toNumber = require('./toNumber');\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0,\n    MAX_INTEGER = 1.7976931348623157e+308;\n\n/**\n * Converts `value` to a finite number.\n *\n * @static\n * @memberOf _\n * @since 4.12.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {number} Returns the converted number.\n * @example\n *\n * _.toFinite(3.2);\n * // => 3.2\n *\n * _.toFinite(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toFinite(Infinity);\n * // => 1.7976931348623157e+308\n *\n * _.toFinite('3.2');\n * // => 3.2\n */\nfunction toFinite(value) {\n  if (!value) {\n    return value === 0 ? value : 0;\n  }\n  value = toNumber(value);\n  if (value === INFINITY || value === -INFINITY) {\n    var sign = (value < 0 ? -1 : 1);\n    return sign * MAX_INTEGER;\n  }\n  return value === value ? value : 0;\n}\n\nmodule.exports = toFinite;\n", "var baseInRange = require('./_baseInRange'),\n    toFinite = require('./toFinite'),\n    toNumber = require('./toNumber');\n\n/**\n * Checks if `n` is between `start` and up to, but not including, `end`. If\n * `end` is not specified, it's set to `start` with `start` then set to `0`.\n * If `start` is greater than `end` the params are swapped to support\n * negative ranges.\n *\n * @static\n * @memberOf _\n * @since 3.3.0\n * @category Number\n * @param {number} number The number to check.\n * @param {number} [start=0] The start of the range.\n * @param {number} end The end of the range.\n * @returns {boolean} Returns `true` if `number` is in the range, else `false`.\n * @see _.range, _.rangeRight\n * @example\n *\n * _.inRange(3, 2, 4);\n * // => true\n *\n * _.inRange(4, 8);\n * // => true\n *\n * _.inRange(4, 2);\n * // => false\n *\n * _.inRange(2, 2);\n * // => false\n *\n * _.inRange(1.2, 2);\n * // => true\n *\n * _.inRange(5.2, 4);\n * // => false\n *\n * _.inRange(-3, -2, -6);\n * // => true\n */\nfunction inRange(number, start, end) {\n  start = toFinite(start);\n  if (end === undefined) {\n    end = start;\n    start = 0;\n  } else {\n    end = toFinite(end);\n  }\n  number = toNumber(number);\n  return baseInRange(number, start, end);\n}\n\nmodule.exports = inRange;\n", "/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeCeil = Math.ceil,\n    nativeMax = Math.max;\n\n/**\n * The base implementation of `_.range` and `_.rangeRight` which doesn't\n * coerce arguments.\n *\n * @private\n * @param {number} start The start of the range.\n * @param {number} end The end of the range.\n * @param {number} step The value to increment or decrement by.\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Array} Returns the range of numbers.\n */\nfunction baseRange(start, end, step, fromRight) {\n  var index = -1,\n      length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),\n      result = Array(length);\n\n  while (length--) {\n    result[fromRight ? length : ++index] = start;\n    start += step;\n  }\n  return result;\n}\n\nmodule.exports = baseRange;\n", "/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This method is loosely based on\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3);\n * // => true\n *\n * _.isLength(Number.MIN_VALUE);\n * // => false\n *\n * _.isLength(Infinity);\n * // => false\n *\n * _.isLength('3');\n * // => false\n */\nfunction isLength(value) {\n  return typeof value == 'number' &&\n    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\nmodule.exports = isLength;\n", "var isFunction = require('./isFunction'),\n    isLength = require('./isLength');\n\n/**\n * Checks if `value` is array-like. A value is considered array-like if it's\n * not a function and has a `value.length` that's an integer greater than or\n * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n * @example\n *\n * _.isArrayLike([1, 2, 3]);\n * // => true\n *\n * _.isArrayLike(document.body.children);\n * // => true\n *\n * _.isArrayLike('abc');\n * // => true\n *\n * _.isArrayLike(_.noop);\n * // => false\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(value.length) && !isFunction(value);\n}\n\nmodule.exports = isArrayLike;\n", "/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/** Used to detect unsigned integer values. */\nvar reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  var type = typeof value;\n  length = length == null ? MAX_SAFE_INTEGER : length;\n\n  return !!length &&\n    (type == 'number' ||\n      (type != 'symbol' && reIsUint.test(value))) &&\n        (value > -1 && value % 1 == 0 && value < length);\n}\n\nmodule.exports = isIndex;\n", "var eq = require('./eq'),\n    isArrayLike = require('./isArrayLike'),\n    isIndex = require('./_isIndex'),\n    isObject = require('./isObject');\n\n/**\n * Checks if the given arguments are from an iteratee call.\n *\n * @private\n * @param {*} value The potential iteratee value argument.\n * @param {*} index The potential iteratee index or key argument.\n * @param {*} object The potential iteratee object argument.\n * @returns {boolean} Returns `true` if the arguments are from an iteratee call,\n *  else `false`.\n */\nfunction isIterateeCall(value, index, object) {\n  if (!isObject(object)) {\n    return false;\n  }\n  var type = typeof index;\n  if (type == 'number'\n        ? (isArrayLike(object) && isIndex(index, object.length))\n        : (type == 'string' && index in object)\n      ) {\n    return eq(object[index], value);\n  }\n  return false;\n}\n\nmodule.exports = isIterateeCall;\n", "var baseRange = require('./_baseRange'),\n    isIterateeCall = require('./_isIterateeCall'),\n    toFinite = require('./toFinite');\n\n/**\n * Creates a `_.range` or `_.rangeRight` function.\n *\n * @private\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Function} Returns the new range function.\n */\nfunction createRange(fromRight) {\n  return function(start, end, step) {\n    if (step && typeof step != 'number' && isIterateeCall(start, end, step)) {\n      end = step = undefined;\n    }\n    // Ensure the sign of `-0` is preserved.\n    start = toFinite(start);\n    if (end === undefined) {\n      end = start;\n      start = 0;\n    } else {\n      end = toFinite(end);\n    }\n    step = step === undefined ? (start < end ? 1 : -1) : toFinite(step);\n    return baseRange(start, end, step, fromRight);\n  };\n}\n\nmodule.exports = createRange;\n", "var createRange = require('./_createRange');\n\n/**\n * Creates an array of numbers (positive and/or negative) progressing from\n * `start` up to, but not including, `end`. A step of `-1` is used if a negative\n * `start` is specified without an `end` or `step`. If `end` is not specified,\n * it's set to `start` with `start` then set to `0`.\n *\n * **Note:** JavaScript follows the IEEE-754 standard for resolving\n * floating-point values which can produce unexpected results.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Util\n * @param {number} [start=0] The start of the range.\n * @param {number} end The end of the range.\n * @param {number} [step=1] The value to increment or decrement by.\n * @returns {Array} Returns the range of numbers.\n * @see _.inRange, _.rangeRight\n * @example\n *\n * _.range(4);\n * // => [0, 1, 2, 3]\n *\n * _.range(-4);\n * // => [0, -1, -2, -3]\n *\n * _.range(1, 5);\n * // => [1, 2, 3, 4]\n *\n * _.range(0, 20, 5);\n * // => [0, 5, 10, 15]\n *\n * _.range(0, -4, -1);\n * // => [0, -1, -2, -3]\n *\n * _.range(1, 4, 0);\n * // => [1, 1, 1]\n *\n * _.range(0);\n * // => []\n */\nvar range = createRange();\n\nmodule.exports = range;\n", "import inRange from 'lodash/inRange';\nimport range from 'lodash/range';\n\nimport { ELLIPSIS } from 'constants/index';\n\nimport {\n  MAX_PAGINATION_BATCH_LENGTH,\n  MAX_PAGINATION_SLOTS,\n  MIN_PAGINATION_BATCH_LENGTH\n} from './getPagination.config';\n\nexport interface GetPaginationType {\n  currentPage: number;\n  totalPages: number;\n}\n\nexport const getPagination = ({\n  currentPage,\n  totalPages\n}: GetPaginationType) => {\n  const previousPage = currentPage - 1;\n  const nextPage = currentPage + 1;\n\n  if (totalPages <= MAX_PAGINATION_SLOTS) {\n    return range(1, totalPages + 1).map((paginationItem) =>\n      String(paginationItem)\n    );\n  }\n\n  const trimBatch = (batch: number[], comparableBatch: number[]) =>\n    batch.includes(currentPage)\n      ? batch\n      : batch.slice(0, MAX_PAGINATION_SLOTS - comparableBatch.length - 1);\n\n  const isLeftBatchInRange = inRange(\n    nextPage - 1,\n    MIN_PAGINATION_BATCH_LENGTH,\n    MAX_PAGINATION_BATCH_LENGTH\n  );\n\n  const isRightBatchInRange = inRange(\n    previousPage + 1,\n    totalPages - MIN_PAGINATION_BATCH_LENGTH,\n    totalPages - 1\n  );\n\n  const leftBatch = isLeftBatchInRange\n    ? range(1, nextPage + 1)\n    : range(1, MAX_PAGINATION_BATCH_LENGTH - 1);\n\n  const rightBatch = isRightBatchInRange\n    ? range(previousPage, totalPages + 1)\n    : range(totalPages - MIN_PAGINATION_BATCH_LENGTH + 1, totalPages + 1);\n\n  const trimmedLeftBatch = trimBatch(leftBatch, rightBatch);\n  const trimmedRightBatch = trimBatch(rightBatch.reverse(), leftBatch);\n  const mergedEdgeBatches = trimmedLeftBatch.concat(trimmedRightBatch);\n  const middleBatch = [ELLIPSIS, previousPage, currentPage, nextPage, ELLIPSIS];\n\n  const [firstLeftBatchItem] = trimmedLeftBatch;\n  const [firstRightBatchItem] = trimmedRightBatch;\n\n  const paginationItems = mergedEdgeBatches.includes(currentPage)\n    ? [...trimmedLeftBatch, ELLIPSIS, ...trimmedRightBatch.reverse()]\n    : [firstLeftBatchItem, ...middleBatch, firstRightBatchItem];\n\n  const paginationItemsAsStrings = paginationItems.map((paginationItem) =>\n    String(paginationItem)\n  );\n\n  return paginationItemsAsStrings;\n};\n"],
  "mappings": "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",
  "names": []
}
