{
  "version": 3,
  "sources": ["../../src/components/ProviderInitializer/ProviderInitializer.tsx"],
  "sourcesContent": ["import { useEffect, useRef } from 'react';\nimport { getNetworkConfigFromApi, useGetAccountFromApi } from 'apiCalls';\nimport {\n  DEVNET_CHAIN_ID,\n  MAINNET_CHAIN_ID,\n  TESTNET_CHAIN_ID\n} from 'constants/index';\nimport { useLoginService } from 'hooks/login/useLoginService';\nimport { useWalletConnectV2Login } from 'hooks/login/useWalletConnectV2Login';\nimport { useWebViewLogin } from 'hooks/login/useWebViewLogin';\nimport {\n  setAccountProvider,\n  setExternalProviderAsAccountProvider\n} from 'providers/accountProvider';\nimport { loginAction } from 'reduxStore/commonActions';\nimport { useDispatch, useSelector } from 'reduxStore/DappProviderContext';\nimport {\n  addressSelector,\n  ledgerAccountSelector\n} from 'reduxStore/selectors/accountInfoSelectors';\nimport {\n  walletConnectLoginSelector,\n  walletLoginSelector,\n  ledgerLoginSelector,\n  isLoggedInSelector,\n  tokenLoginSelector,\n  loginInfoSelector\n} from 'reduxStore/selectors/loginInfoSelectors';\nimport {\n  chainIDSelector,\n  networkSelector,\n  walletAddressSelector\n} from 'reduxStore/selectors/networkConfigSelectors';\nimport {\n  setAccount,\n  setIsAccountLoading,\n  setAccountLoadingError,\n  setLedgerAccount,\n  setWalletLogin,\n  setTokenLogin,\n  setIsWalletConnectV2Initialized,\n  setAddress,\n  updateNetworkConfig\n} from 'reduxStore/slices';\nimport { decodeNativeAuthToken } from 'services/nativeAuth/helpers';\nimport { LoginMethodsEnum } from 'types/enums.types';\nimport {\n  getAddress,\n  getLatestNonce,\n  newWalletProvider,\n  emptyProvider,\n  refreshAccount\n} from 'utils/account';\nimport { parseNavigationParams } from 'utils/parseNavigationParams';\n\nimport { isContract } from 'utils/smartContracts';\nimport {\n  getOperaProvider,\n  getCrossWindowProvider,\n  getExtensionProvider,\n  getPasskeyProvider,\n  processModifiedAccount,\n  getMetamaskProvider,\n  getIframeProvider\n} from './helpers';\nimport { useSetLedgerProvider } from './hooks';\n\nlet initalizingLedger = false;\n\nexport function ProviderInitializer() {\n  const network = useSelector(networkSelector);\n  const walletAddress = useSelector(walletAddressSelector);\n  const walletConnectLogin = useSelector(walletConnectLoginSelector);\n  const { loginMethod, iframeLoginType } = useSelector(loginInfoSelector);\n  const walletLogin = useSelector(walletLoginSelector);\n  const address = useSelector(addressSelector);\n  const ledgerAccount = useSelector(ledgerAccountSelector);\n  const ledgerLogin = useSelector(ledgerLoginSelector);\n  const isLoggedIn = useSelector(isLoggedInSelector);\n  const chainID = useSelector(chainIDSelector);\n  const tokenLogin = useSelector(tokenLoginSelector);\n  const nativeAuthConfig = tokenLogin?.nativeAuthConfig;\n  const loginService = useLoginService(\n    nativeAuthConfig ? nativeAuthConfig : false\n  );\n  const {\n    data: account,\n    isLoading: isAccountLoading,\n    error: accountError\n  } = useGetAccountFromApi(address);\n\n  const initializedAccountRef = useRef(false);\n  const dispatch = useDispatch();\n  const { setLedgerProvider, ledgerData } = useSetLedgerProvider();\n  useWebViewLogin();\n\n  const { callbackRoute, logoutRoute: wcLogoutRoute } = walletConnectLogin\n    ? walletConnectLogin\n    : { callbackRoute: '', logoutRoute: '' };\n\n  const [initWalletConnectV2LoginProvider] = useWalletConnectV2Login({\n    callbackRoute,\n    logoutRoute: wcLogoutRoute\n  });\n\n  useEffect(() => {\n    refreshNetworkConfig();\n  }, [network]);\n\n  useEffect(() => {\n    initializeProvider();\n  }, [address, loginMethod, chainID]);\n\n  useEffect(() => {\n    checkAddress();\n  }, [tokenLogin?.nativeAuthToken, address]);\n\n  useEffect(() => {\n    setupAccount();\n  }, [account, isAccountLoading]);\n\n  useEffect(() => {\n    // prevent balance double fetching by handling ledgerAccount data separately\n    setLedgerAccountInfo();\n  }, [ledgerAccount, isLoggedIn, ledgerData]);\n\n  // We need to get the roundDuration for networks that do not support websocket (e.g. sovereign)\n  // The round duration is used for polling interval\n  async function refreshNetworkConfig() {\n    const needsRoundDurationForPollingInterval =\n      network.chainId &&\n      ![DEVNET_CHAIN_ID, TESTNET_CHAIN_ID, MAINNET_CHAIN_ID].includes(\n        network.chainId\n      ) &&\n      !network.roundDuration;\n\n    const shouldGetConfig =\n      !network.chainId || needsRoundDurationForPollingInterval;\n\n    if (!shouldGetConfig) {\n      return;\n    }\n\n    try {\n      const networkConfig = await getNetworkConfigFromApi();\n      const hasDifferentNetworkConfig =\n        networkConfig &&\n        (network.chainId !== networkConfig.erd_chain_id ||\n          network.roundDuration !== networkConfig.erd_round_duration);\n\n      if (hasDifferentNetworkConfig) {\n        dispatch(\n          updateNetworkConfig({\n            chainId: networkConfig.erd_chain_id,\n            roundDuration: networkConfig.erd_round_duration\n          })\n        );\n      }\n    } catch (err) {\n      console.error('failed refreshing chainId ', err);\n    }\n  }\n\n  function setLedgerAccountInfo() {\n    if (ledgerAccount == null && ledgerLogin != null && ledgerData) {\n      dispatch(\n        setLedgerAccount({\n          index: ledgerLogin.index,\n          address,\n          hasContractDataEnabled: ledgerData.dataEnabled,\n          version: ledgerData.version\n        })\n      );\n    }\n  }\n\n  async function checkAddress() {\n    const {\n      remainingParams: { impersonate, multisig }\n    } = parseNavigationParams(['impersonate']);\n\n    const addressIsContract = isContract(address);\n\n    if (\n      !tokenLogin?.nativeAuthToken ||\n      impersonate ||\n      multisig ||\n      addressIsContract\n    ) {\n      return;\n    }\n\n    const decoded = decodeNativeAuthToken(tokenLogin?.nativeAuthToken);\n\n    if (decoded?.address && decoded.address !== address) {\n      dispatch(setAddress(decoded.address));\n      await refreshAccount();\n    }\n  }\n\n  async function setupAccount() {\n    if (isAccountLoading) {\n      dispatch(setIsAccountLoading(true));\n      return;\n    }\n\n    if (accountError) {\n      dispatch(setAccountLoadingError('Failed getting account'));\n      console.error('Failed getting account ', accountError);\n      return;\n    }\n\n    if (initializedAccountRef.current) {\n      // account was recently initialized, skip refetching\n      initializedAccountRef.current = false;\n      dispatch(setIsAccountLoading(false));\n      return;\n    }\n\n    if (account) {\n      dispatch(\n        setAccount({\n          ...account,\n          address,\n          nonce: account.nonce.valueOf()\n        })\n      );\n    } else if (!isLoggedIn) {\n      // Clear the address and publicKey if account is not found\n      dispatch(setAddress(''));\n    }\n\n    dispatch(setIsAccountLoading(false));\n  }\n\n  async function tryAuthenticateWalletUser() {\n    const provider = newWalletProvider(walletAddress);\n    setAccountProvider(provider);\n\n    if (walletLogin == null) {\n      return;\n    }\n\n    try {\n      const address = await getAddress();\n      const {\n        clearNavigationHistory,\n        remainingParams: { signature, multisig, impersonate }\n      } = parseNavigationParams([\n        'signature',\n        'loginToken',\n        'address',\n        'multisig',\n        'impersonate'\n      ]);\n\n      if (!address) {\n        setAccountProvider(emptyProvider);\n        dispatch(setTokenLogin(null));\n        dispatch(setWalletLogin(null));\n        return clearNavigationHistory();\n      }\n\n      const account = await processModifiedAccount({\n        loginToken: tokenLogin?.loginToken,\n        extraInfoData: {\n          multisig,\n          impersonate\n        },\n        address,\n        signature,\n        loginService\n      });\n\n      if (account) {\n        initializedAccountRef.current = true;\n        dispatch(setIsAccountLoading(true));\n\n        dispatch(\n          loginAction({\n            address: account.address,\n            loginMethod: LoginMethodsEnum.wallet\n          })\n        );\n\n        dispatch(\n          setAccount({\n            ...account,\n            nonce: getLatestNonce(account)\n          })\n        );\n        dispatch(setIsAccountLoading(false));\n      }\n\n      clearNavigationHistory();\n    } catch (e) {\n      console.error('Failed authenticating wallet user ', e);\n    }\n\n    dispatch(setWalletLogin(null));\n  }\n\n  async function setExtensionProvider() {\n    const address = await getAddress();\n    const provider = await getExtensionProvider(address);\n    if (provider) {\n      setAccountProvider(provider);\n    }\n  }\n\n  async function setPasskeyProvider() {\n    const address = await getAddress();\n    const provider = await getPasskeyProvider(address);\n    if (provider) {\n      setAccountProvider(provider);\n    }\n  }\n\n  async function setMetamaskProvider() {\n    const address = await getAddress();\n    const provider = await getMetamaskProvider(address);\n    if (provider) {\n      setAccountProvider(provider);\n    }\n  }\n\n  async function setOperaProvider() {\n    const address = await getAddress();\n    const provider = await getOperaProvider(address);\n    if (provider) {\n      setAccountProvider(provider);\n    }\n  }\n\n  async function setCrossWindowProvider() {\n    const address = await getAddress();\n    const provider = await getCrossWindowProvider({\n      address,\n      walletUrl: network.walletAddress\n    });\n    if (provider) {\n      setAccountProvider(provider);\n    }\n  }\n\n  async function setIframeProvider() {\n    const address = await getAddress();\n\n    if (!network.metamaskSnapWalletAddress) {\n      throw new Error('Metamask snap wallet URL is not set.');\n    }\n    const provider = await getIframeProvider({\n      address,\n      walletUrl: network.metamaskSnapWalletAddress,\n      loginType: iframeLoginType\n    });\n    if (provider) {\n      setAccountProvider(provider);\n    }\n  }\n\n  async function setWalletConnectV2Provider() {\n    try {\n      // Trigger loader until wallet connect has been initialized\n      dispatch(setIsWalletConnectV2Initialized(true));\n      await initWalletConnectV2LoginProvider(false);\n    } catch {\n      console.error('Could not initialize WalletConnect');\n    } finally {\n      dispatch(setIsWalletConnectV2Initialized(false));\n    }\n  }\n\n  async function initializeProvider() {\n    if (loginMethod == null || initalizingLedger) {\n      return;\n    }\n\n    switch (loginMethod) {\n      case LoginMethodsEnum.ledger: {\n        initalizingLedger = true;\n        await setLedgerProvider();\n        initalizingLedger = false;\n        break;\n      }\n\n      case LoginMethodsEnum.walletconnectv2: {\n        setWalletConnectV2Provider();\n        break;\n      }\n\n      case LoginMethodsEnum.extension: {\n        setExtensionProvider();\n        break;\n      }\n\n      case LoginMethodsEnum.passkey: {\n        setPasskeyProvider();\n        break;\n      }\n\n      case LoginMethodsEnum.metamask: {\n        setMetamaskProvider();\n        break;\n      }\n\n      case LoginMethodsEnum.opera: {\n        setOperaProvider();\n        break;\n      }\n\n      case LoginMethodsEnum.crossWindow: {\n        setCrossWindowProvider();\n        break;\n      }\n\n      case LoginMethodsEnum.iframe:\n        setIframeProvider();\n        break;\n\n      case LoginMethodsEnum.extra: {\n        setExternalProviderAsAccountProvider();\n        break;\n      }\n\n      case LoginMethodsEnum.wallet:\n      case LoginMethodsEnum.none: {\n        tryAuthenticateWalletUser();\n        break;\n      }\n\n      default:\n        return;\n    }\n  }\n\n  return null;\n}\n"],
  "mappings": "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",
  "names": []
}
