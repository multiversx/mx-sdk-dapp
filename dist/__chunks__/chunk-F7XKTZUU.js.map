{
  "version": 3,
  "sources": ["../../src/services/nativeAuth/helpers/getLatestBlockHash.ts"],
  "sourcesContent": ["import axios from 'axios';\nimport { BLOCKS_ENDPOINT } from 'apiCalls/endpoints';\nimport { retryMultipleTimes } from 'utils/retryMultipleTimes';\n\nexport interface LatestBlockHashType {\n  hash: string;\n  timestamp: number;\n}\n\nconst getBlockFromPosition = 4;\nconst cachingDurationMs = 30000; // 30 seconds, a block hash is valid for 1 minute from its generation\n//this is an object with .current, so it doesn't get affected by closure and is always a fresh value\nconst cachedResponse: Record<string, LatestBlockHashType | null> = {\n  current: null\n};\n\nconst requestPromise: {\n  current: Promise<LatestBlockHashType> | null;\n} = {\n  current: null\n};\n\nconst getLatestBlockHashFromServer = retryMultipleTimes(\n  async (\n    apiUrl: string,\n    blockHashShard?: number,\n    getBlockHash?: () => Promise<string>\n  ): Promise<LatestBlockHashType | null> => {\n    // get current block hash\n    if (getBlockHash) {\n      const timestamp = Math.floor(Date.now() / 1000);\n      const hash = await getBlockHash();\n\n      return { hash, timestamp };\n    }\n\n    //get the penultimate block hash (3 shards + the meta chain) to make sure that the block is seen by auth server\n    const { data } = await axios.get<Array<LatestBlockHashType>>(\n      `${apiUrl}/${BLOCKS_ENDPOINT}?from=${getBlockFromPosition}&size=1&fields=hash,timestamp${\n        blockHashShard ? '&shard=' + blockHashShard : ''\n      }`\n    );\n    const [latestBlock] = data;\n    return latestBlock;\n  }\n);\n\n// TODO: make getLatestBlockHash accept an object and make getBlockHash param mandatory (to replace axios call)\nexport async function getLatestBlockHash(\n  apiUrl: string,\n  blockHashShard?: number,\n  getBlockHash?: () => Promise<string>,\n  noCache?: boolean\n): Promise<LatestBlockHashType> {\n  if (apiUrl == null) {\n    throw new Error('missing api url');\n  }\n\n  const currentTimestampMs = Date.now();\n  if (\n    cachedResponse.current != null &&\n    currentTimestampMs <\n      cachedResponse.current.timestamp * 1000 + cachingDurationMs &&\n    !noCache\n  ) {\n    return cachedResponse.current;\n  }\n  //this will prevent multiple calls to this function from generating multiple hashes\n  if (requestPromise.current != null) {\n    //if there is already an await in progress for the API, just return the result of that promise\n    return await requestPromise.current;\n  }\n\n  //if a promise is not in progress, get a new promise and add it to the promise\n  requestPromise.current = getLatestBlockHashFromServer(\n    apiUrl,\n    blockHashShard,\n    getBlockHash\n  );\n\n  try {\n    const response = await requestPromise.current;\n    if (response == null) {\n      requestPromise.current = null;\n      throw new Error('could not get block hash');\n    }\n    //set the new response, the new expiry and unlock the regeneration flow for the next expiration period\n    cachedResponse.current = {\n      hash: response.hash,\n      timestamp: response.timestamp\n    };\n\n    requestPromise.current = null;\n    return response;\n  } catch (err) {\n    requestPromise.current = null;\n    return null as any;\n  }\n}\n"],
  "mappings": "sIAAA,IACA,IADA,qBASA,GAAM,GAAuB,EACvB,EAAoB,IAEpB,EAA6D,CACjE,QAAS,IACX,EAEM,EAEF,CACF,QAAS,IACX,EAEM,EAA+B,EACnC,CACE,EACA,EACA,IACwC,0BAExC,GAAI,EAAc,CAChB,GAAM,GAAY,KAAK,MAAM,KAAK,IAAI,EAAI,GAAI,EAG9C,MAAO,CAAE,KAFI,KAAM,GAAa,EAEjB,WAAU,CAC3B,CAGA,GAAM,CAAE,QAAS,KAAM,GAAM,IAC3B,GAAG,KAAU,UAAwB,iCACnC,EAAiB,UAAY,EAAiB,IAElD,EACM,CAAC,GAAe,EACtB,MAAO,EACT,EACF,EAGA,WACE,EACA,EACA,EACA,EAC8B,gCAC9B,GAAI,GAAU,KACZ,KAAM,IAAI,OAAM,iBAAiB,EAGnC,GAAM,GAAqB,KAAK,IAAI,EACpC,GACE,EAAe,SAAW,MAC1B,EACE,EAAe,QAAQ,UAAY,IAAO,GAC5C,CAAC,EAED,MAAO,GAAe,QAGxB,GAAI,EAAe,SAAW,KAE5B,MAAO,MAAM,GAAe,QAI9B,EAAe,QAAU,EACvB,EACA,EACA,CACF,EAEA,GAAI,CACF,GAAM,GAAW,KAAM,GAAe,QACtC,GAAI,GAAY,KACd,QAAe,QAAU,KACnB,GAAI,OAAM,0BAA0B,EAG5C,SAAe,QAAU,CACvB,KAAM,EAAS,KACf,UAAW,EAAS,SACtB,EAEA,EAAe,QAAU,KAClB,CACT,OAAS,EAAP,CACA,SAAe,QAAU,KAClB,IACT,CACF",
  "names": []
}
