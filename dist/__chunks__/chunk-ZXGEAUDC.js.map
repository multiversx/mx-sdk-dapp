{
  "version": 3,
  "sources": ["../../src/hooks/login/useIframeLogin.ts"],
  "sourcesContent": ["import { useState } from 'react';\nimport { processModifiedAccount } from 'components/ProviderInitializer/helpers/processModifiedAccount';\nimport { SECOND_LOGIN_ATTEMPT_ERROR } from 'constants/errorsMessages';\nimport {\n  IframeLoginTypes,\n  IframeProvider\n} from 'lib/sdkWebWalletIframeProvider';\nimport { setAccountProvider } from 'providers/accountProvider';\nimport { loginAction } from 'reduxStore/commonActions';\nimport { useDispatch, useSelector } from 'reduxStore/DappProviderContext';\nimport { networkSelector } from 'reduxStore/selectors/networkConfigSelectors';\nimport { setAccount } from 'reduxStore/slices';\nimport {\n  LoginHookGenericStateType,\n  LoginMethodsEnum,\n  OnProviderLoginType\n} from 'types';\nimport { getLatestNonce } from 'utils/account/getLatestNonce';\nimport { getIsLoggedIn } from 'utils/getIsLoggedIn';\nimport { getWindowLocation } from 'utils/window/getWindowLocation';\nimport { clearInitiatedLogins } from './helpers';\nimport { useLoginService } from './useLoginService';\n\nexport type UseIframeLoginReturnType = [\n  (loginType: IframeLoginTypes) => void,\n  LoginHookGenericStateType\n];\n\nexport const useIframeLogin = ({\n  callbackRoute,\n  token: tokenToSign,\n  nativeAuth,\n  walletAddress\n}: OnProviderLoginType & {\n  walletAddress?: string;\n}): UseIframeLoginReturnType => {\n  const [error, setError] = useState('');\n  const [isLoading, setIsLoading] = useState(false);\n  const hasNativeAuth = nativeAuth != null;\n  const loginService = useLoginService(nativeAuth);\n  let token = tokenToSign;\n  const network = useSelector(networkSelector);\n\n  const dispatch = useDispatch();\n  const isLoggedIn = getIsLoggedIn();\n\n  async function initiateLogin(loginType = IframeLoginTypes.metamask) {\n    if (isLoggedIn) {\n      throw new Error(SECOND_LOGIN_ATTEMPT_ERROR);\n    }\n\n    clearInitiatedLogins({\n      skipLoginMethod: LoginMethodsEnum.iframe\n    });\n\n    setIsLoading(true);\n    const provider = IframeProvider.getInstance();\n\n    const walletUrl = walletAddress ?? network.metamaskSnapWalletAddress;\n\n    if (!walletUrl) {\n      setError('Iframe snap wallet URL is not set');\n      return;\n    }\n\n    provider.setLoginType(loginType);\n    provider.setWalletUrl(walletUrl);\n\n    const isSuccessfullyInitialized: boolean = await provider.init();\n\n    try {\n      if (!isSuccessfullyInitialized) {\n        console.warn(\n          'Something went wrong trying to redirect to wallet login..'\n        );\n        return;\n      }\n\n      const { origin, pathname } = getWindowLocation();\n      const callbackUrl: string = encodeURIComponent(\n        `${origin}${callbackRoute ?? pathname}`\n      );\n\n      if (hasNativeAuth && !token) {\n        token = await loginService.getNativeAuthLoginToken();\n\n        // Fetching block failed\n        if (!token) {\n          console.warn('Fetching block failed. Login cancelled.');\n          return;\n        }\n      }\n\n      if (token) {\n        loginService.setLoginToken(token);\n      }\n\n      const providerLoginData = {\n        callbackUrl,\n        ...(token && { token })\n      };\n\n      const { signature, address, multisig, impersonate } =\n        await provider.login(providerLoginData);\n\n      setAccountProvider(provider);\n\n      if (!address) {\n        setIsLoading(false);\n        console.warn('Login cancelled.');\n        return;\n      }\n\n      const account = await processModifiedAccount({\n        loginToken: token,\n        extraInfoData: { multisig, impersonate },\n        address,\n        signature,\n        loginService\n      });\n\n      if (!account) {\n        return;\n      }\n\n      dispatch(\n        loginAction({\n          address: account.address,\n          loginMethod: LoginMethodsEnum.iframe,\n          iframeLoginType: loginType\n        })\n      );\n\n      dispatch(\n        setAccount({\n          ...account,\n          nonce: getLatestNonce(account)\n        })\n      );\n    } catch (error) {\n      console.error('error loging in', error);\n      // TODO: can be any or typed error\n      setError('error logging in' + (error as any).message);\n    } finally {\n      setIsLoading(false);\n    }\n  }\n\n  const loginFailed = Boolean(error);\n\n  return [\n    initiateLogin,\n    {\n      loginFailed,\n      error,\n      isLoading: isLoading && !loginFailed,\n      isLoggedIn: isLoggedIn && !loginFailed\n    }\n  ];\n};\n"],
  "mappings": "msBAAA,qCAEA,IAMA,IAEA,KACA,IACA,IAKA,KAEA,IASO,GAAM,IAAiB,CAAC,CAC7B,gBACA,MAAO,EACP,aACA,mBAG8B,CAC9B,GAAM,CAAC,EAAO,GAAY,EAAS,EAAE,EAC/B,CAAC,EAAW,GAAgB,EAAS,EAAK,EAC1C,EAAgB,GAAc,KAC9B,EAAe,EAAgB,CAAU,EAC3C,EAAQ,EACN,EAAU,EAAY,CAAe,EAErC,EAAW,EAAY,EACvB,EAAa,EAAc,EAEjC,YAAoE,mCAAvC,EAAY,EAAiB,SAAU,CAClE,GAAI,EACF,KAAM,IAAI,OAAM,CAA0B,EAG5C,EAAqB,CACnB,gBAAiB,QACnB,CAAC,EAED,EAAa,EAAI,EACjB,GAAM,GAAW,EAAe,YAAY,EAEtC,EAAY,UAAiB,EAAQ,0BAE3C,GAAI,CAAC,EAAW,CACd,EAAS,mCAAmC,EAC5C,MACF,CAEA,EAAS,aAAa,CAAS,EAC/B,EAAS,aAAa,CAAS,EAE/B,GAAM,GAAqC,KAAM,GAAS,KAAK,EAE/D,GAAI,CACF,GAAI,CAAC,EAA2B,CAC9B,QAAQ,KACN,2DACF,EACA,MACF,CAEA,GAAM,CAAE,SAAQ,YAAa,EAAkB,EACzC,EAAsB,mBAC1B,GAAG,IAAS,UAAiB,GAC/B,EAEA,GAAI,GAAiB,CAAC,GACpB,GAAQ,KAAM,GAAa,wBAAwB,EAG/C,CAAC,GAAO,CACV,QAAQ,KAAK,yCAAyC,EACtD,MACF,CAGF,AAAI,GACF,EAAa,cAAc,CAAK,EAGlC,GAAM,GAAoB,GACxB,eACI,GAAS,CAAE,OAAM,GAGjB,CAAE,YAAW,UAAS,WAAU,eACpC,KAAM,GAAS,MAAM,CAAiB,EAIxC,GAFA,EAAmB,CAAQ,EAEvB,CAAC,EAAS,CACZ,EAAa,EAAK,EAClB,QAAQ,KAAK,kBAAkB,EAC/B,MACF,CAEA,GAAM,GAAU,KAAM,GAAuB,CAC3C,WAAY,EACZ,cAAe,CAAE,WAAU,aAAY,EACvC,UACA,YACA,cACF,CAAC,EAED,GAAI,CAAC,EACH,OAGF,EACE,EAAY,CACV,QAAS,EAAQ,QACjB,YAAa,SACb,gBAAiB,CACnB,CAAC,CACH,EAEA,EACE,EAAW,OACN,GADM,CAET,MAAO,EAAe,CAAO,CAC/B,EAAC,CACH,CACF,OAAS,EAAP,CACA,QAAQ,MAAM,kBAAmB,CAAK,EAEtC,EAAS,mBAAsB,EAAc,OAAO,CACtD,QAAE,CACA,EAAa,EAAK,CACpB,CACF,GAEA,GAAM,GAAc,QAAQ,CAAK,EAEjC,MAAO,CACL,EACA,CACE,cACA,QACA,UAAW,GAAa,CAAC,EACzB,WAAY,GAAc,CAAC,CAC7B,CACF,CACF",
  "names": []
}
