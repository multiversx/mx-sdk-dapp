{
  "version": 3,
  "sources": ["../../src/utils/transactions/getTokenFromData.ts"],
  "sourcesContent": ["import { Address } from '@multiversx/sdk-core';\nimport BigNumber from 'bignumber.js';\nimport { TransactionTypesEnum } from 'types/enums.types';\nimport { addressIsValid } from 'utils/account/addressIsValid';\nimport { decodePart } from 'utils/decoders/decodePart';\n\nconst noData = {\n  tokenId: '',\n  amount: ''\n};\n\nexport const decodeData = (data: string) => {\n  const nonceIndex = 2;\n  const amountIndex = 3;\n  const parts = data.split('@');\n  const decodedParts = parts.map((part, i) =>\n    [nonceIndex, amountIndex].includes(i) ? part : decodePart(part)\n  );\n  return decodedParts;\n};\n\nexport function getTokenFromData(data?: string): {\n  tokenId: string;\n  amount: string;\n  collection?: string;\n  nonce?: string;\n  receiver?: string;\n} {\n  if (!data) {\n    return noData;\n  }\n\n  const isTokenTransfer = data.startsWith(TransactionTypesEnum.ESDTTransfer);\n  const isNftTransfer =\n    data.startsWith(TransactionTypesEnum.ESDTNFTTransfer) && data.includes('@');\n  const isNftBurn =\n    data.startsWith(TransactionTypesEnum.ESDTNFTBurn) && data.includes('@');\n\n  if (isTokenTransfer) {\n    const [, encodedToken, encodedAmount] = data.split('@');\n    try {\n      const tokenId = Buffer.from(encodedToken, 'hex').toString('ascii');\n\n      if (!tokenId) {\n        return noData;\n      }\n\n      const amount = new BigNumber(\n        '0x' + encodedAmount.replace('0x', '')\n      ).toString(10);\n\n      return {\n        tokenId,\n        amount\n      };\n    } catch (e) {\n      console.error('Error getting token from transaction data', e);\n    }\n  }\n\n  if (isNftTransfer) {\n    try {\n      const [, /*ESDTNFTTransfer*/ collection, nonce, quantity, receiver] =\n        decodeData(data);\n      if (\n        [collection, nonce, quantity, receiver].every((el) => Boolean(el)) &&\n        addressIsValid(new Address(receiver).bech32())\n      ) {\n        return {\n          tokenId: `${collection}-${nonce}`,\n          amount: new BigNumber(quantity, 16).toString(10),\n          collection,\n          nonce,\n          receiver: new Address(receiver).bech32()\n        };\n      }\n    } catch (err) {}\n  }\n\n  if (isNftBurn) {\n    try {\n      const [, /*ESDTNFTBurn*/ collection, nonce, quantity] = decodeData(data);\n      if ([collection, nonce, quantity].every((el) => Boolean(el))) {\n        return {\n          tokenId: `${collection}-${nonce}`,\n          amount: new BigNumber(quantity, 16).toString(10),\n          collection,\n          nonce\n        };\n      }\n    } catch (err) {}\n  }\n\n  return noData;\n}\n"],
  "mappings": "uLAAA,+CACA,4BAoBO,WAA0B,EAM/B,CACA,GAAI,CAAC,EACH,MAAO,GAGT,GAAM,GAAkB,EAAK,WAAW,cAAiC,EACnE,EACJ,EAAK,WAAW,iBAAoC,GAAK,EAAK,SAAS,GAAG,EACtE,EACJ,EAAK,WAAW,aAAgC,GAAK,EAAK,SAAS,GAAG,EAExE,GAAI,EAAiB,CACnB,GAAM,CAAC,CAAE,EAAc,GAAiB,EAAK,MAAM,GAAG,EACtD,GAAI,CACF,GAAM,GAAU,SAAO,KAAK,EAAc,KAAK,EAAE,SAAS,OAAO,EAEjE,GAAI,CAAC,EACH,MAAO,GAGT,GAAM,GAAS,GAAI,GACjB,KAAO,EAAc,QAAQ,KAAM,EAAE,CACvC,EAAE,SAAS,EAAE,EAEb,MAAO,CACL,UACA,QACF,CACF,OAAS,EAAP,CACA,QAAQ,MAAM,4CAA6C,CAAC,CAC9D,CACF,CAEA,GAAI,EACF,GAAI,CACF,GAAM,CAAC,CAAsB,EAAY,EAAO,EAAU,GACxD,EAAW,CAAI,EACjB,GACE,CAAC,EAAY,EAAO,EAAU,CAAQ,EAAE,MAAM,AAAC,GAAO,QAAQ,CAAE,CAAC,GACjE,EAAe,GAAI,GAAQ,CAAQ,EAAE,OAAO,CAAC,EAE7C,MAAO,CACL,QAAS,GAAG,KAAc,IAC1B,OAAQ,GAAI,GAAU,EAAU,EAAE,EAAE,SAAS,EAAE,EAC/C,aACA,QACA,SAAU,GAAI,GAAQ,CAAQ,EAAE,OAAO,CACzC,CAEJ,OAAS,EAAP,CAAa,CAGjB,GAAI,EACF,GAAI,CACF,GAAM,CAAC,CAAkB,EAAY,EAAO,GAAY,EAAW,CAAI,EACvE,GAAI,CAAC,EAAY,EAAO,CAAQ,EAAE,MAAM,AAAC,GAAO,QAAQ,CAAE,CAAC,EACzD,MAAO,CACL,QAAS,GAAG,KAAc,IAC1B,OAAQ,GAAI,GAAU,EAAU,EAAE,EAAE,SAAS,EAAE,EAC/C,aACA,OACF,CAEJ,OAAS,EAAP,CAAa,CAGjB,MAAO,EACT,CA9FA,GAMM,GAKO,EAXb,aAEA,IACA,IACA,IAEA,AAAM,EAAS,CACb,QAAS,GACT,OAAQ,EACV,EAEa,EAAa,AAAC,GAIJ,AADP,EAAK,MAAM,GAAG,EACD,IAAI,CAAC,EAAM,IACpC,CAAC,EAAY,CAAW,EAAE,SAAS,CAAC,EAAI,EAAO,EAAW,CAAI,CAChE",
  "names": []
}
