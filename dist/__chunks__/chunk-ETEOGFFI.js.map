{
  "version": 3,
  "sources": ["../../src/hooks/login/useWalletConnectV2Login.ts"],
  "sourcesContent": ["import { useEffect, useRef, useState } from 'react';\n\nimport { useGetAccountProvider } from 'hooks/account';\nimport { useUpdateEffect } from 'hooks/useUpdateEffect';\nimport { setAccountProvider } from 'providers/accountProvider';\nimport { emptyProvider, getProviderType } from 'providers/utils';\nimport { loginAction } from 'reduxStore/commonActions';\nimport { useDispatch, useSelector } from 'reduxStore/DappProviderContext';\nimport { loginMethodSelector, logoutRouteSelector } from 'reduxStore/selectors';\nimport {\n  walletConnectDeepLinkSelector,\n  walletConnectV2OptionsSelector,\n  walletConnectV2ProjectIdSelector,\n  walletConnectV2RelaySelector\n} from 'reduxStore/selectors/networkConfigSelectors';\nimport { setWalletConnectLogin } from 'reduxStore/slices';\nimport { LoginMethodsEnum } from 'types/enums.types';\nimport { getHasNativeAuth } from 'utils/getHasNativeAuth';\nimport { getIsLoggedIn } from 'utils/getIsLoggedIn';\nimport { optionalRedirect } from 'utils/internal';\nimport { logout } from 'utils/logout';\nimport { waitForChainID } from 'utils/waitForChainID';\nimport {\n  PairingTypes,\n  SessionEventTypes,\n  WalletConnectOptionalMethodsEnum,\n  WalletConnectV2Provider\n} from 'utils/walletconnect/__sdkWalletconnectProvider';\nimport { getWindowLocation } from 'utils/window/getWindowLocation';\nimport {\n  LoginHookGenericStateType,\n  OnProviderLoginType\n} from '../../types/login.types';\nimport { clearInitiatedLogins } from './helpers';\nimport { useLoginService } from './useLoginService';\n\nexport enum WalletConnectV2Error {\n  invalidAddress = 'Invalid address',\n  invalidConfig = 'Invalid WalletConnect setup',\n  invalidTopic = 'Expired connection',\n  sessionExpired = 'Unable to connect to existing session',\n  connectError = 'Unable to connect',\n  userRejected = 'User rejected connection proposal',\n  userRejectedExisting = 'User rejected existing connection proposal',\n  errorLogout = 'Unable to remove existing pairing',\n  invalidChainID = 'Invalid chainID'\n}\n\nexport interface InitWalletConnectV2Type extends OnProviderLoginType {\n  logoutRoute?: string;\n  customRequestMethods?: Array<string>;\n}\n\nexport interface WalletConnectV2LoginHookCustomStateType {\n  uriDeepLink: string;\n  cancelLogin: () => Promise<void>;\n  connectExisting: (pairing: PairingTypes.Struct) => Promise<void>;\n  removeExistingPairing: (topic: string) => Promise<void>;\n  walletConnectUri?: string;\n  wcPairings?: PairingTypes.Struct[];\n}\n\nexport type WalletConnectV2LoginHookReturnType = [\n  (loginProvider?: boolean) => Promise<void>,\n  LoginHookGenericStateType,\n  WalletConnectV2LoginHookCustomStateType\n];\n\nexport const useWalletConnectV2Login = ({\n  callbackRoute,\n  token: tokenToSign,\n  nativeAuth,\n  onLoginRedirect,\n  logoutRoute: providerLogoutRoute,\n  customRequestMethods = []\n}: InitWalletConnectV2Type): WalletConnectV2LoginHookReturnType => {\n  const dispatch = useDispatch();\n  const hasNativeAuth = getHasNativeAuth(nativeAuth);\n  const loginService = useLoginService(hasNativeAuth ? nativeAuth : false);\n  let token = tokenToSign;\n\n  const [error, setError] = useState<string>('');\n  const [wcUri, setWcUri] = useState<string>('');\n  const [isLoading, setIsLoading] = useState<boolean>(true);\n  const [wcPairings, setWcPairings] = useState<\n    PairingTypes.Struct[] | undefined\n  >([]);\n  const [sessionProvider, setSessionProvider] =\n    useState<WalletConnectV2Provider | null>(null);\n  const { provider } = useGetAccountProvider();\n  const walletConnectV2RelayAddress = useSelector(walletConnectV2RelaySelector);\n  const walletConnectV2ProjectId = useSelector(\n    walletConnectV2ProjectIdSelector\n  );\n\n  const walletConnectV2Options = useSelector(walletConnectV2OptionsSelector);\n  const walletConnectDeepLink = useSelector(walletConnectDeepLinkSelector);\n  const dappLogoutRoute = useSelector(logoutRouteSelector);\n  const loginMethod = useSelector(loginMethodSelector);\n  const providerRef = useRef<any>(provider);\n  const isInitialisingRef = useRef<boolean>(false);\n  const mounted = useRef(false);\n  const logoutRoute = providerLogoutRoute ?? dappLogoutRoute ?? '/';\n  const dappMethods: string[] = [\n    WalletConnectOptionalMethodsEnum.CANCEL_ACTION,\n    ...customRequestMethods\n  ];\n\n  if (tokenToSign) {\n    dappMethods.push(WalletConnectOptionalMethodsEnum.SIGN_LOGIN_TOKEN);\n  }\n\n  if (hasNativeAuth) {\n    dappMethods.push(WalletConnectOptionalMethodsEnum.SIGN_NATIVE_AUTH_TOKEN);\n  }\n\n  const uriDeepLink = !isLoading\n    ? `${walletConnectDeepLink}?wallet-connect=${encodeURIComponent(wcUri)}`\n    : '';\n\n  const loginFailed = Boolean(error);\n  const isLoggedIn = getIsLoggedIn();\n\n  const handleOnLogout = () => {\n    logout(logoutRoute);\n  };\n\n  const handleOnEvent = (event: SessionEventTypes['event']) => {\n    console.log('WalletConnect Session Event: ', event);\n  };\n\n  const handleOnLogin = async () => {\n    try {\n      if (isInitialisingRef.current || providerRef.current == null) {\n        return;\n      }\n\n      if (!mounted.current) {\n        try {\n          await providerRef.current?.logout();\n        } catch {\n          console.warn('Unable to logout');\n        }\n\n        return;\n      }\n\n      const address = await providerRef.current?.getAddress?.();\n\n      if (!address) {\n        console.warn('Login cancelled.');\n        return;\n      }\n\n      const signature = await providerRef.current?.getSignature();\n      const loginActionData = {\n        address: address,\n        loginMethod: LoginMethodsEnum.walletconnectv2\n      };\n\n      const loginData = {\n        logoutRoute: logoutRoute,\n        loginType: 'walletconnectv2',\n        callbackRoute: callbackRoute ?? getWindowLocation().href\n      };\n\n      dispatch(setWalletConnectLogin(loginData));\n\n      if (signature) {\n        loginService.setTokenLoginInfo({ signature, address });\n      }\n\n      dispatch(loginAction(loginActionData));\n      optionalRedirect({\n        callbackRoute,\n        onLoginRedirect,\n        options: { address, signature }\n      });\n    } catch (err) {\n      setError(WalletConnectV2Error.userRejected);\n      console.error(err);\n    }\n  };\n\n  const cancelLogin = async () => {\n    const providerType = getProviderType(providerRef.current);\n\n    if (providerType !== LoginMethodsEnum.walletconnectv2) {\n      return;\n    }\n\n    try {\n      const connectedSessions =\n        providerRef.current?.walletConnector?.session?.getAll() ?? [];\n\n      if (connectedSessions.length > 0) {\n        await providerRef.current?.logout();\n      }\n\n      providerRef.current = emptyProvider;\n      setSessionProvider(null);\n    } catch {\n      console.warn('Unable to logout');\n    }\n\n    return;\n  };\n\n  const connectExisting = async (pairing: PairingTypes.Struct) => {\n    if (!walletConnectV2RelayAddress || !walletConnectV2ProjectId) {\n      setError(WalletConnectV2Error.invalidConfig);\n      return;\n    }\n\n    if (!pairing || !pairing.topic) {\n      setError(WalletConnectV2Error.invalidTopic);\n      return;\n    }\n\n    try {\n      const providerType = providerRef.current\n        ? getProviderType(providerRef.current)\n        : false;\n\n      if (providerType !== LoginMethodsEnum.walletconnectv2) {\n        // Prevent redirecting to wallet login hook\n        await initiateLogin();\n\n        return;\n      }\n\n      setIsLoading(true);\n      await cancelLogin();\n\n      if (hasNativeAuth && !token) {\n        token = await loginService.getNativeAuthLoginToken();\n        // Fetching block failed\n        if (!token) {\n          console.warn('Fetching block failed. Login cancelled.');\n          return;\n        }\n      }\n\n      if (token) {\n        loginService.setLoginToken(token);\n      }\n\n      await initiateLogin(false);\n\n      const { approval } = await providerRef.current?.connect({\n        topic: pairing.topic,\n        methods: dappMethods\n      });\n\n      try {\n        await providerRef.current?.login({ approval, token });\n      } catch (err) {\n        console.error(WalletConnectV2Error.userRejectedExisting, err);\n        setError(WalletConnectV2Error.userRejectedExisting);\n        setIsLoading(true);\n        await initiateLogin();\n      }\n    } catch (err) {\n      console.error(WalletConnectV2Error.sessionExpired, err);\n      setError(WalletConnectV2Error.sessionExpired);\n    } finally {\n      setWcPairings(providerRef.current?.pairings);\n    }\n  };\n\n  const removeExistingPairing = async (topic: string) => {\n    try {\n      if (topic) {\n        await providerRef.current?.logout({\n          topic\n        });\n      }\n    } catch (err) {\n      console.error(WalletConnectV2Error.errorLogout, err);\n      setError(WalletConnectV2Error.errorLogout);\n    } finally {\n      const newPairings = await providerRef.current?.getPairings();\n      setWcPairings(newPairings);\n    }\n  };\n\n  async function initiateLogin(loginProvider = true) {\n    clearInitiatedLogins();\n\n    const chainId = await waitForChainID({ maxRetries: 15 });\n\n    if (!chainId) {\n      console.error(WalletConnectV2Error.invalidChainID);\n      setError(WalletConnectV2Error.invalidChainID);\n      return;\n    }\n\n    if (!walletConnectV2ProjectId || !walletConnectV2RelayAddress) {\n      console.error(WalletConnectV2Error.invalidConfig);\n      setError(WalletConnectV2Error.invalidConfig);\n      return;\n    }\n\n    const isLoggedIn = getIsLoggedIn();\n    const cannotLogin = mounted.current === false && !isLoggedIn;\n    const isInitialized = providerRef.current?.isInitialized?.();\n\n    if (isInitialisingRef.current || cannotLogin || isInitialized) {\n      return;\n    }\n\n    isInitialisingRef.current = true;\n\n    if (providerRef.current?.walletConnector) {\n      await providerRef.current.init();\n\n      setSessionProvider(providerRef.current);\n\n      isInitialisingRef.current = false;\n\n      if (loginProvider) {\n        await generateWcUri();\n      }\n\n      return;\n    }\n\n    const providerHandlers = {\n      onClientLogin: handleOnLogin,\n      onClientLogout: handleOnLogout,\n      onClientEvent: handleOnEvent\n    };\n\n    const newProvider = new WalletConnectV2Provider(\n      providerHandlers,\n      chainId,\n      walletConnectV2RelayAddress,\n      walletConnectV2ProjectId,\n      walletConnectV2Options\n    );\n\n    await newProvider.init();\n    setSessionProvider(newProvider);\n    providerRef.current = newProvider;\n    isInitialisingRef.current = false;\n\n    if (loginProvider) {\n      setWcPairings(newProvider.pairings);\n      await generateWcUri();\n    }\n\n    return;\n  }\n\n  async function generateWcUri() {\n    if (!providerRef.current) {\n      return;\n    }\n\n    if (!walletConnectV2RelayAddress || !walletConnectV2ProjectId) {\n      setError(WalletConnectV2Error.invalidConfig);\n      return;\n    }\n\n    try {\n      // Do not do any other actions if component is not mounted\n      if (!mounted.current) {\n        return;\n      }\n\n      const { uri, approval } = await providerRef.current?.connect({\n        methods: dappMethods\n      });\n\n      const hasUri = Boolean(uri);\n\n      if (!hasUri) {\n        return;\n      }\n\n      setWcUri(uri);\n\n      if (walletConnectV2Options?.logger === 'debug') {\n        console.log('WalletConnect uri: ', uri);\n      }\n\n      if (hasNativeAuth && !token) {\n        token = await loginService.getNativeAuthLoginToken();\n        // Fetching block failed\n        if (!token) {\n          console.warn('Fetching block failed. Login cancelled.');\n          return;\n        }\n      }\n\n      if (token) {\n        loginService.setLoginToken(token);\n      }\n\n      const providerType = providerRef.current\n        ? getProviderType(providerRef.current)\n        : false;\n\n      if (providerType !== LoginMethodsEnum.walletconnectv2) {\n        // Prevent redirecting to wallet login hook\n        setIsLoading(true);\n        await initiateLogin();\n        return;\n      }\n\n      try {\n        await providerRef.current?.login({ approval, token });\n      } catch (err) {\n        console.error(WalletConnectV2Error.userRejected, err);\n        setError(WalletConnectV2Error.userRejected);\n        setIsLoading(true);\n      }\n    } catch (err) {\n      console.error(WalletConnectV2Error.connectError, err);\n    }\n  }\n\n  useUpdateEffect(() => {\n    providerRef.current = provider;\n  }, [provider]);\n\n  useEffect(() => {\n    mounted.current = true;\n\n    return () => {\n      mounted.current = false;\n    };\n  }, []);\n\n  useEffect(() => {\n    setIsLoading(!wcUri);\n  }, [wcUri]);\n\n  useEffect(() => {\n    if (!sessionProvider) {\n      return;\n    }\n\n    // Check if a new session has been created is already connected\n    const isConnected =\n      Boolean(sessionProvider.session) ||\n      loginMethod === LoginMethodsEnum.walletconnectv2;\n\n    // Set new provider only if account is logged in and if walletConnect session is available\n    if (isConnected && isLoggedIn) {\n      setAccountProvider(sessionProvider);\n    }\n  }, [sessionProvider, isLoggedIn]);\n\n  return [\n    initiateLogin,\n    {\n      error,\n      loginFailed,\n      isLoading: isLoading && !loginFailed,\n      isLoggedIn: isLoggedIn && !loginFailed\n    },\n    {\n      uriDeepLink,\n      walletConnectUri: wcUri,\n      cancelLogin,\n      connectExisting,\n      removeExistingPairing,\n      wcPairings\n    }\n  ];\n};\n"],
  "mappings": "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",
  "names": []
}
