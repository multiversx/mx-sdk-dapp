{
  "version": 3,
  "sources": ["../../src/hooks/transactions/useSignTransactionsWithDevice.tsx"],
  "sourcesContent": ["import { Transaction } from '@multiversx/sdk-core';\nimport { getScamAddressData } from 'apiCalls/utils/getScamAddressData';\n\nimport { useGetAccountInfo } from 'hooks/account/useGetAccountInfo';\nimport { useGetAccountProvider } from 'hooks/account/useGetAccountProvider';\nimport { useSignMultipleTransactions } from 'hooks/transactions/useSignMultipleTransactions';\n\nimport { useDispatch, useSelector } from 'reduxStore/DappProviderContext';\nimport { egldLabelSelector, walletAddressSelector } from 'reduxStore/selectors';\nimport {\n  moveTransactionsToSignedState,\n  setSignTransactionsError\n} from 'reduxStore/slices';\nimport {\n  ActiveLedgerTransactionType,\n  DeviceSignedTransactions,\n  LoginMethodsEnum,\n  MultiSignTransactionType,\n  Nullable,\n  TransactionBatchStatusesEnum\n} from 'types';\nimport { getIsProviderEqualTo } from 'utils/account/getIsProviderEqualTo';\nimport { safeRedirect } from 'utils/redirect';\nimport { parseTransactionAfterSigning } from 'utils/transactions/parseTransactionAfterSigning';\nimport { getWindowLocation } from 'utils/window/getWindowLocation';\nimport { checkNeedsGuardianSigning, useGetLedgerProvider } from './helpers';\nimport { getShouldMoveTransactionsToSignedState } from './helpers/getShouldMoveTransactionsToSignedState';\nimport { useClearTransactionsToSignWithWarning } from './helpers/useClearTransactionsToSignWithWarning';\nimport { useSignTransactionsCommonData } from './useSignTransactionsCommonData';\n\nexport interface UseSignTransactionsWithDevicePropsType {\n  onCancel: () => void;\n  verifyReceiverScam?: boolean;\n  hasGuardianScreen?: boolean;\n}\n\nexport interface UseSignTransactionsWithDeviceReturnType {\n  allTransactions: MultiSignTransactionType[];\n  onSignTransaction: () => Promise<void>;\n  onNext: () => void;\n  onPrev: () => void;\n  onAbort: () => void;\n  waitingForDevice: boolean;\n  isLastTransaction: boolean;\n  currentStep: number;\n  signedTransactions?: DeviceSignedTransactions;\n  setSignedTransactions?: React.Dispatch<\n    React.SetStateAction<DeviceSignedTransactions | undefined>\n  >;\n  currentTransaction: ActiveLedgerTransactionType | null;\n  callbackRoute?: string;\n}\n\nexport function useSignTransactionsWithDevice(\n  props: UseSignTransactionsWithDevicePropsType\n): UseSignTransactionsWithDeviceReturnType {\n  const { onCancel, verifyReceiverScam = true, hasGuardianScreen } = props;\n  const { transactionsToSign, hasTransactions } =\n    useSignTransactionsCommonData();\n  const walletAddress = useSelector(walletAddressSelector);\n  const getLedgerProvider = useGetLedgerProvider();\n\n  const egldLabel = useSelector(egldLabelSelector);\n  const { account } = useGetAccountInfo();\n  const { address, isGuarded, activeGuardianAddress } = account;\n  const { provider, providerType } = useGetAccountProvider();\n  const dispatch = useDispatch();\n  const clearTransactionsToSignWithWarning =\n    useClearTransactionsToSignWithWarning();\n\n  const {\n    transactions,\n    sessionId,\n    callbackRoute,\n    customTransactionInformation\n  } = transactionsToSign || {};\n\n  function handleTransactionSignError(errorMessage: string) {\n    if (sessionId) {\n      dispatch(\n        moveTransactionsToSignedState({\n          sessionId,\n          status: TransactionBatchStatusesEnum.cancelled\n        })\n      );\n    }\n\n    dispatch(setSignTransactionsError(errorMessage));\n  }\n\n  const { pathname } = getWindowLocation();\n  const locationIncludesCallbackRoute =\n    callbackRoute != null && pathname.includes(callbackRoute);\n\n  const allowGuardian = !customTransactionInformation?.skipGuardian;\n\n  async function handleTransactionsSignSuccess(\n    newSignedTransactions: Transaction[]\n  ) {\n    const shouldMoveTransactionsToSignedState =\n      getShouldMoveTransactionsToSignedState(newSignedTransactions);\n\n    if (!shouldMoveTransactionsToSignedState) {\n      return;\n    }\n\n    const { needs2FaSigning, guardTransactions } = checkNeedsGuardianSigning({\n      transactions: newSignedTransactions,\n      sessionId,\n      callbackRoute,\n      isGuarded: isGuarded && allowGuardian,\n      walletAddress\n    });\n\n    let signedTransactionsArray = newSignedTransactions.map((tx) =>\n      parseTransactionAfterSigning(tx)\n    );\n\n    if (needs2FaSigning) {\n      const guardedTransactions = await guardTransactions();\n      signedTransactionsArray = guardedTransactions\n        ? guardedTransactions.map((tx) => parseTransactionAfterSigning(tx))\n        : [];\n    }\n\n    if (!sessionId) {\n      return;\n    }\n\n    dispatch(\n      moveTransactionsToSignedState({\n        sessionId: sessionId,\n        status: TransactionBatchStatusesEnum.signed,\n        transactions: signedTransactionsArray\n      })\n    );\n\n    if (\n      callbackRoute != null &&\n      customTransactionInformation?.redirectAfterSign &&\n      !locationIncludesCallbackRoute\n    ) {\n      safeRedirect({ url: callbackRoute });\n    }\n  }\n\n  function handleCancel() {\n    onCancel();\n    clearTransactionsToSignWithWarning(sessionId);\n  }\n\n  async function handleSignTransaction(\n    transaction: Nullable<Transaction>\n  ): Promise<Nullable<Transaction | undefined>> {\n    const connectedProvider =\n      providerType !== LoginMethodsEnum.ledger\n        ? provider\n        : await getLedgerProvider();\n\n    if (!transaction) {\n      return null;\n    }\n\n    const signedTransaction = await connectedProvider.signTransaction(\n      transaction\n    );\n\n    return signedTransaction;\n  }\n\n  const signMultipleTxReturnValues = useSignMultipleTransactions({\n    address,\n    egldLabel,\n    activeGuardianAddress:\n      isGuarded && allowGuardian ? activeGuardianAddress : undefined,\n    transactionsToSign: hasTransactions ? transactions : [],\n    onGetScamAddressData: verifyReceiverScam ? getScamAddressData : null,\n    isLedger: getIsProviderEqualTo(LoginMethodsEnum.ledger),\n    hasGuardianScreen,\n    onCancel: handleCancel,\n    onSignTransaction: handleSignTransaction,\n    onTransactionsSignError: handleTransactionSignError,\n    onTransactionsSignSuccess: handleTransactionsSignSuccess\n  });\n\n  return {\n    ...signMultipleTxReturnValues,\n    callbackRoute,\n    waitingForDevice: signMultipleTxReturnValues.waitingForDevice\n  };\n}\n"],
  "mappings": "w2BAAA,IACA,KAOA,KACA,KAIA,KASA,KACA,KACA,KA6BO,YACL,EACyC,CACzC,GAAM,CAAE,WAAU,qBAAqB,GAAM,qBAAsB,EAC7D,CAAE,qBAAoB,mBAC1B,EAA8B,EAC1B,EAAgB,EAAY,CAAqB,EACjD,EAAoB,EAAqB,EAEzC,EAAY,EAAY,CAAiB,EACzC,CAAE,WAAY,EAAkB,EAChC,CAAE,UAAS,YAAW,yBAA0B,EAChD,CAAE,WAAU,gBAAiB,EAAsB,EACnD,EAAW,EAAY,EACvB,EACJ,EAAsC,EAElC,CACJ,eACA,YACA,gBACA,gCACE,GAAsB,CAAC,EAE3B,WAAoC,EAAsB,CACxD,AAAI,GACF,EACE,EAA8B,CAC5B,YACA,OAAQ,WACV,CAAC,CACH,EAGF,EAAS,EAAyB,CAAY,CAAC,CACjD,CAEA,GAAM,CAAE,YAAa,EAAkB,EACjC,EACJ,GAAiB,MAAQ,EAAS,SAAS,CAAa,EAEpD,EAAgB,CAAC,YAA8B,cAErD,YACE,EACA,gCAIA,GAAI,CAFF,EAAuC,CAAqB,EAG5D,OAGF,GAAM,CAAE,kBAAiB,sBAAsB,EAA0B,CACvE,aAAc,EACd,YACA,gBACA,UAAW,GAAa,EACxB,eACF,CAAC,EAEG,EAA0B,EAAsB,IAAI,AAAC,GACvD,EAA6B,CAAE,CACjC,EAEA,GAAI,EAAiB,CACnB,GAAM,GAAsB,KAAM,IAAkB,EACpD,EAA0B,EACtB,EAAoB,IAAI,AAAC,IAAO,EAA6B,EAAE,CAAC,EAChE,CAAC,CACP,CAEA,AAAI,CAAC,GAIL,GACE,EAA8B,CAC5B,UAAW,EACX,OAAQ,SACR,aAAc,CAChB,CAAC,CACH,EAGE,GAAiB,MACjB,kBAA8B,oBAC9B,CAAC,GAED,EAAa,CAAE,IAAK,CAAc,CAAC,EAEvC,GAEA,aAAwB,CACtB,EAAS,EACT,EAAmC,CAAS,CAC9C,CAEA,YACE,EAC4C,gCAC5C,GAAM,GACJ,IAAiB,SACb,EACA,KAAM,GAAkB,EAE9B,MAAK,GAIqB,KAAM,GAAkB,gBAChD,CACF,EALS,IAQX,GAEA,GAAM,GAA6B,EAA4B,CAC7D,UACA,YACA,sBACE,GAAa,EAAgB,EAAwB,OACvD,mBAAoB,EAAkB,EAAe,CAAC,EACtD,qBAAsB,EAAqB,EAAqB,KAChE,SAAU,EAAqB,QAAuB,EACtD,oBACA,SAAU,GACV,kBAAmB,GACnB,wBAAyB,EACzB,0BAA2B,EAC7B,CAAC,EAED,MAAO,QACF,GADE,CAEL,gBACA,iBAAkB,EAA2B,gBAC/C,EACF",
  "names": []
}
