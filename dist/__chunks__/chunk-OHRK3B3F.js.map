{
  "version": 3,
  "sources": ["../../src/hooks/login/useWebWalletLogin.ts"],
  "sourcesContent": ["import { useState } from 'react';\nimport { SECOND_LOGIN_ATTEMPT_ERROR } from 'constants/errorsMessages';\nimport { useDispatch, useSelector } from 'reduxStore/DappProviderContext';\nimport { networkSelector } from 'reduxStore/selectors';\nimport { setWalletLogin, setCustomWalletAddress } from 'reduxStore/slices';\nimport { newWalletProvider } from 'utils';\nimport { getIsLoggedIn } from 'utils/getIsLoggedIn';\nimport { getWindowLocation } from 'utils/window/getWindowLocation';\nimport {\n  AccountInfoSliceNetworkType,\n  InitiateLoginFunctionType,\n  LoginHookGenericStateType,\n  OnProviderLoginType\n} from '../../types';\nimport { sanitizeCallbackUrl } from '../../utils/sanitizeCallbackUrl';\nimport { useLoginService } from './useLoginService';\n\nexport interface UseWebWalletLoginPropsType\n  extends Omit<OnProviderLoginType, 'onLoginRedirect'> {\n  redirectDelayMilliseconds?: number;\n  /**\n   * @param {string} customWalletAddress if set, will be used as main `walletAddress`\n   * @description\n   * The `customWalletAddress` property is used to override the default `walletAddress`.\n   * This is useful when you want to use a custom wallet provider.\n   * It overrides the network's wallet address, including the wallet address from the custom network config specified in the `DappProvider`.\n   * @example\n   * <WebWalletLoginButton\n      {...otherLoginProps}\n      customWalletAddress=\"https://custom-web-wallet.com\"\n     >\n   */\n  customWalletAddress?: AccountInfoSliceNetworkType['customWalletAddress'];\n}\n\nexport type UseWebWalletLoginReturnType = [\n  InitiateLoginFunctionType,\n  LoginHookGenericStateType\n];\n\nexport const useWebWalletLogin = ({\n  callbackRoute,\n  token: tokenToSign,\n  nativeAuth,\n  redirectDelayMilliseconds = 100,\n  customWalletAddress\n}: UseWebWalletLoginPropsType): UseWebWalletLoginReturnType => {\n  const [error, setError] = useState('');\n  const [isLoading, setIsLoading] = useState(false);\n  const network = useSelector(networkSelector);\n  const dispatch = useDispatch();\n  const isLoggedIn = getIsLoggedIn();\n  const hasNativeAuth = Boolean(nativeAuth);\n  const loginService = useLoginService(nativeAuth);\n  let token = tokenToSign;\n\n  async function initiateLogin() {\n    if (isLoggedIn) {\n      throw new Error(SECOND_LOGIN_ATTEMPT_ERROR);\n    }\n\n    dispatch(setCustomWalletAddress(customWalletAddress));\n\n    try {\n      setIsLoading(true);\n      const provider = newWalletProvider(\n        customWalletAddress ?? network.walletAddress\n      );\n\n      const now = new Date();\n      const expires: number = now.setMinutes(now.getMinutes() + 3) / 1000;\n      const walletLoginData = {\n        data: {},\n        expires: expires\n      };\n\n      if (hasNativeAuth && !token) {\n        token = await loginService.getNativeAuthLoginToken();\n        // Fetching block failed\n        if (!token) {\n          console.warn('Login cancelled.');\n          return;\n        }\n      }\n\n      if (token) {\n        loginService.setLoginToken(token);\n      }\n\n      const { origin } = getWindowLocation();\n      const targetUrl = window?.location\n        ? `${origin}${callbackRoute}`\n        : `${callbackRoute}`;\n      const params = new URLSearchParams(document?.location.search);\n\n      // skip login when an address param is prefilled in URL\n      const skipLogin = params.get('address');\n\n      if (!skipLogin) {\n        dispatch(setWalletLogin(walletLoginData));\n      }\n\n      const sanitizedCallbackUrl = sanitizeCallbackUrl(targetUrl);\n      const callbackUrl = encodeURIComponent(sanitizedCallbackUrl);\n\n      const loginData = {\n        callbackUrl,\n        ...(token && { token }),\n        redirectDelayMilliseconds\n      };\n\n      await provider.login(loginData);\n    } catch (error) {\n      console.error(error);\n      setError('error logging in' + (error as any).message);\n    } finally {\n      setIsLoading(false);\n    }\n  }\n\n  const loginFailed = Boolean(error);\n\n  return [\n    initiateLogin,\n    {\n      error,\n      loginFailed,\n      isLoading: isLoading && !loginFailed,\n      isLoggedIn: isLoggedIn && !loginFailed\n    }\n  ];\n};\n"],
  "mappings": "kjBAAA,IACA,IADA,iCAGA,IACA,IAGA,IAiCO,GAAM,IAAoB,CAAC,CAChC,gBACA,MAAO,EACP,aACA,4BAA4B,IAC5B,yBAC6D,CAC7D,GAAM,CAAC,EAAO,GAAY,EAAS,EAAE,EAC/B,CAAC,EAAW,GAAgB,EAAS,EAAK,EAC1C,EAAU,EAAY,CAAe,EACrC,EAAW,EAAY,EACvB,EAAa,EAAc,EAC3B,EAAgB,QAAQ,CAAU,EAClC,EAAe,EAAgB,CAAU,EAC3C,EAAQ,EAEZ,YAA+B,gCAC7B,GAAI,EACF,KAAM,IAAI,OAAM,CAA0B,EAG5C,EAAS,EAAuB,CAAmB,CAAC,EAEpD,GAAI,CACF,EAAa,EAAI,EACjB,GAAM,GAAW,EACf,UAAuB,EAAQ,aACjC,EAEM,EAAM,GAAI,MACV,EAAkB,EAAI,WAAW,EAAI,WAAW,EAAI,CAAC,EAAI,IACzD,EAAkB,CACtB,KAAM,CAAC,EACP,QAAS,CACX,EAEA,GAAI,GAAiB,CAAC,GACpB,GAAQ,KAAM,GAAa,wBAAwB,EAE/C,CAAC,GAAO,CACV,QAAQ,KAAK,kBAAkB,EAC/B,MACF,CAGF,AAAI,GACF,EAAa,cAAc,CAAK,EAGlC,GAAM,CAAE,UAAW,EAAkB,EAC/B,EAAY,qBAAQ,SACtB,GAAG,IAAS,IACZ,GAAG,IAMP,AAAK,AAFa,AAHH,GAAI,iBAAgB,+BAAU,SAAS,MAAM,EAGnC,IAAI,SAAS,GAGpC,EAAS,EAAe,CAAe,CAAC,EAG1C,GAAM,GAAuB,EAAoB,CAAS,EACpD,EAAc,mBAAmB,CAAoB,EAErD,EAAY,KAChB,eACI,GAAS,CAAE,OAAM,GAFL,CAGhB,2BACF,GAEA,KAAM,GAAS,MAAM,CAAS,CAChC,OAAS,EAAP,CACA,QAAQ,MAAM,CAAK,EACnB,EAAS,mBAAsB,EAAc,OAAO,CACtD,QAAE,CACA,EAAa,EAAK,CACpB,CACF,GAEA,GAAM,GAAc,QAAQ,CAAK,EAEjC,MAAO,CACL,EACA,CACE,QACA,cACA,UAAW,GAAa,CAAC,EACzB,WAAY,GAAc,CAAC,CAC7B,CACF,CACF",
  "names": []
}
