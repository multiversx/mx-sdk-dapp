{
  "version": 3,
  "sources": ["../../src/utils/operations/formatAmount.ts"],
  "sourcesContent": ["import { TokenTransfer } from '@multiversx/sdk-core';\nimport BigNumber from 'bignumber.js';\nimport { DECIMALS, DIGITS, ZERO } from 'constants/index';\nimport { stringIsInteger } from 'utils/validation/stringIsInteger';\nimport { pipe } from './pipe';\n\nBigNumber.config({ ROUNDING_MODE: BigNumber.ROUND_FLOOR });\n\nexport interface FormatAmountType {\n  input: string;\n  decimals?: number;\n  digits?: number;\n  showIsLessThanDecimalsLabel?: boolean;\n  showLastNonZeroDecimal?: boolean;\n  addCommas?: boolean;\n}\n\nexport function formatAmount({\n  input,\n  decimals = DECIMALS,\n  digits = DIGITS,\n  showLastNonZeroDecimal = true,\n  showIsLessThanDecimalsLabel = false,\n  addCommas = false\n}: FormatAmountType) {\n  if (!stringIsInteger(input, false)) {\n    throw new Error('Invalid input');\n  }\n\n  const isNegative = new BigNumber(input).isNegative();\n  let modInput = input;\n\n  if (isNegative) {\n    // remove - at start of input\n    modInput = input.substring(1);\n  }\n\n  return (\n    pipe(modInput as string)\n      // format\n      .then(() =>\n        TokenTransfer.fungibleFromBigInteger('', modInput as string, decimals)\n          .amountAsBigInteger.shiftedBy(-decimals)\n          .toFixed(decimals)\n      )\n\n      // format\n      .then((current) => {\n        const bnBalance = new BigNumber(current);\n\n        if (bnBalance.isZero()) {\n          return ZERO;\n        }\n        const balance = bnBalance.toString(10);\n        const [integerPart, decimalPart] = balance.split('.');\n        const bNdecimalPart = new BigNumber(decimalPart || 0);\n\n        const decimalPlaces = pipe(0)\n          .if(Boolean(decimalPart && showLastNonZeroDecimal))\n          .then(() => Math.max(decimalPart.length, digits))\n\n          .if(bNdecimalPart.isZero() && !showLastNonZeroDecimal)\n          .then(0)\n\n          .if(Boolean(decimalPart && !showLastNonZeroDecimal))\n          .then(() => Math.min(decimalPart.length, digits))\n\n          .valueOf();\n\n        const shownDecimalsAreZero =\n          decimalPart &&\n          digits >= 1 &&\n          digits <= decimalPart.length &&\n          bNdecimalPart.isGreaterThan(0) &&\n          new BigNumber(decimalPart.substring(0, digits)).isZero();\n\n        const formatted = bnBalance.toFormat(decimalPlaces);\n\n        const formattedBalance = pipe(balance)\n          .if(addCommas)\n          .then(formatted)\n\n          .if(Boolean(shownDecimalsAreZero))\n          .then((current) => {\n            const integerPartZero = new BigNumber(integerPart).isZero();\n            const [numericPart, decimalSide] = current.split('.');\n\n            const zeroPlaceholders = new Array(digits - 1).fill(0);\n            const zeros = [...zeroPlaceholders, 0].join('');\n            const minAmount = [...zeroPlaceholders, 1].join(''); // 00..1\n\n            if (!integerPartZero) {\n              return `${numericPart}.${zeros}`;\n            }\n\n            if (showIsLessThanDecimalsLabel) {\n              return `<${numericPart}.${minAmount}`;\n            }\n\n            if (!showLastNonZeroDecimal) {\n              return numericPart;\n            }\n\n            return `${numericPart}.${decimalSide}`;\n          })\n\n          .if(Boolean(!shownDecimalsAreZero && decimalPart))\n          .then((current) => {\n            const [numericPart] = current.split('.');\n            let decimalSide = decimalPart.substring(0, decimalPlaces);\n\n            if (showLastNonZeroDecimal) {\n              const noOfZerosAtEnd = digits - decimalSide.length;\n\n              if (noOfZerosAtEnd > 0) {\n                const zeroPadding = Array(noOfZerosAtEnd).fill(0).join('');\n                decimalSide = `${decimalSide}${zeroPadding}`;\n                return `${numericPart}.${decimalSide}`;\n              }\n\n              return current;\n            }\n\n            if (!decimalSide) {\n              return numericPart;\n            }\n\n            return `${numericPart}.${decimalSide}`;\n          })\n\n          .valueOf();\n\n        return formattedBalance;\n      })\n      .if(isNegative)\n      .then((current) => `-${current}`)\n\n      .valueOf()\n  );\n}\n"],
  "mappings": "qMAAA,qDACA,4BAgBO,WAAsB,CAC3B,QACA,WAAW,EACX,SAAS,EACT,yBAAyB,GACzB,8BAA8B,GAC9B,YAAY,IACO,CACnB,GAAI,CAAC,EAAgB,EAAO,EAAK,EAC/B,KAAM,IAAI,OAAM,eAAe,EAGjC,GAAM,GAAa,GAAI,GAAU,CAAK,EAAE,WAAW,EAC/C,EAAW,EAEf,MAAI,IAEF,GAAW,EAAM,UAAU,CAAC,GAI5B,EAAK,CAAkB,EAEpB,KAAK,IACJ,EAAc,uBAAuB,GAAI,EAAoB,CAAQ,EAClE,mBAAmB,UAAU,CAAC,CAAQ,EACtC,QAAQ,CAAQ,CACrB,EAGC,KAAK,AAAC,GAAY,CACjB,GAAM,GAAY,GAAI,GAAU,CAAO,EAEvC,GAAI,EAAU,OAAO,EACnB,MAAO,GAET,GAAM,GAAU,EAAU,SAAS,EAAE,EAC/B,CAAC,EAAa,GAAe,EAAQ,MAAM,GAAG,EAC9C,EAAgB,GAAI,GAAU,GAAe,CAAC,EAE9C,EAAgB,EAAK,CAAC,EACzB,GAAG,QAAQ,GAAe,CAAsB,CAAC,EACjD,KAAK,IAAM,KAAK,IAAI,EAAY,OAAQ,CAAM,CAAC,EAE/C,GAAG,EAAc,OAAO,GAAK,CAAC,CAAsB,EACpD,KAAK,CAAC,EAEN,GAAG,QAAQ,GAAe,CAAC,CAAsB,CAAC,EAClD,KAAK,IAAM,KAAK,IAAI,EAAY,OAAQ,CAAM,CAAC,EAE/C,QAAQ,EAEL,EACJ,GACA,GAAU,GACV,GAAU,EAAY,QACtB,EAAc,cAAc,CAAC,GAC7B,GAAI,GAAU,EAAY,UAAU,EAAG,CAAM,CAAC,EAAE,OAAO,EAEnD,EAAY,EAAU,SAAS,CAAa,EAwDlD,MAtDyB,GAAK,CAAO,EAClC,GAAG,CAAS,EACZ,KAAK,CAAS,EAEd,GAAG,QAAQ,CAAoB,CAAC,EAChC,KAAK,AAAC,GAAY,CACjB,GAAM,GAAkB,GAAI,GAAU,CAAW,EAAE,OAAO,EACpD,CAAC,EAAa,GAAe,EAAQ,MAAM,GAAG,EAE9C,EAAmB,GAAI,OAAM,EAAS,CAAC,EAAE,KAAK,CAAC,EAC/C,EAAQ,CAAC,GAAG,EAAkB,CAAC,EAAE,KAAK,EAAE,EACxC,EAAY,CAAC,GAAG,EAAkB,CAAC,EAAE,KAAK,EAAE,EAElD,MAAK,GAID,EACK,IAAI,KAAe,IAGvB,EAIE,GAAG,KAAe,IAHhB,EARA,GAAG,KAAe,GAY7B,CAAC,EAEA,GAAG,QAAQ,CAAC,GAAwB,CAAW,CAAC,EAChD,KAAK,AAAC,GAAY,CACjB,GAAM,CAAC,GAAe,EAAQ,MAAM,GAAG,EACnC,EAAc,EAAY,UAAU,EAAG,CAAa,EAExD,GAAI,EAAwB,CAC1B,GAAM,GAAiB,EAAS,EAAY,OAE5C,GAAI,EAAiB,EAAG,CACtB,GAAM,GAAc,MAAM,CAAc,EAAE,KAAK,CAAC,EAAE,KAAK,EAAE,EACzD,SAAc,GAAG,IAAc,IACxB,GAAG,KAAe,GAC3B,CAEA,MAAO,EACT,CAEA,MAAK,GAIE,GAAG,KAAe,IAHhB,CAIX,CAAC,EAEA,QAAQ,CAGb,CAAC,EACA,GAAG,CAAU,EACb,KAAK,AAAC,GAAY,IAAI,GAAS,EAE/B,QAAQ,CAEf,CA3IA,iBAEA,IACA,IACA,IAEA,EAAU,OAAO,CAAE,cAAe,EAAU,WAAY,CAAC",
  "names": []
}
