{
  "version": 3,
  "sources": ["../../src/hooks/login/useLedgerLogin.ts"],
  "sourcesContent": ["import { useEffect, useState } from 'react';\nimport { HWProvider } from '@multiversx/sdk-hw-provider';\nimport { SECOND_LOGIN_ATTEMPT_ERROR } from 'constants/errorsMessages';\nimport { getAccountProvider, getLedgerConfiguration } from 'providers';\nimport { setAccountProvider } from 'providers/accountProvider';\nimport { loginAction } from 'reduxStore/commonActions';\nimport { useDispatch, useSelector } from 'reduxStore/DappProviderContext';\nimport { ledgerAccountSelector } from 'reduxStore/selectors';\nimport {\n  setLedgerAccount,\n  setLedgerLogin,\n  updateLedgerAccount\n} from 'reduxStore/slices';\nimport { LoginMethodsEnum } from 'types/enums.types';\nimport { getLedgerErrorCodes, optionalRedirect } from 'utils/internal';\nimport {\n  InitiateLoginFunctionType,\n  LoginHookGenericStateType,\n  OnProviderLoginType\n} from '../../types';\nimport { getIsLoggedIn } from '../../utils';\nimport { clearInitiatedLogins } from './helpers';\nimport { useAddressScreens } from './useAddressScreens';\nimport { useLoginService } from './useLoginService';\nconst failInitializeErrorText = 'Check if the MultiversX App is open on Ledger';\n\nexport interface UseLedgerLoginPropsType extends OnProviderLoginType {\n  addressesPerPage?: number;\n}\n\nexport interface SelectedAddress {\n  address: string;\n  index: number;\n}\n\nexport interface LedgerLoginHookCustomStateType {\n  accounts: string[];\n  showAddressList: boolean;\n  startIndex: number;\n  selectedAddress: SelectedAddress | null;\n  version: string;\n  contractDataEnabled: boolean;\n  onGoToSpecificPage: (page: number) => void;\n  onGoToPrevPage: () => void;\n  onGoToNextPage: () => void;\n  onSelectAddress: (address: SelectedAddress | null) => void;\n  onConfirmSelectedAddress: () => void;\n}\n\nexport type LedgerLoginHookReturnType = [\n  InitiateLoginFunctionType,\n  LoginHookGenericStateType,\n  LedgerLoginHookCustomStateType\n];\n\nexport const useLedgerLogin = ({\n  callbackRoute,\n  token: tokenToSign,\n  addressesPerPage: configuredAddressesPerPage,\n  nativeAuth,\n  onLoginRedirect\n}: UseLedgerLoginPropsType): LedgerLoginHookReturnType => {\n  const ledgerAccount = useSelector(ledgerAccountSelector);\n  const hwProvider = getAccountProvider() as unknown as HWProvider;\n  const dispatch = useDispatch();\n  const isLoggedIn = getIsLoggedIn();\n  const hasNativeAuth = nativeAuth != null;\n  const loginService = useLoginService(nativeAuth);\n  let token = tokenToSign;\n\n  const {\n    accounts,\n    setAccounts,\n    isLoading,\n    setIsLoading,\n    setShowAddressList,\n    showAddressList,\n    startIndex,\n    selectedAddress,\n    onGoToPrevPage,\n    onGoToNextPage,\n    onGoToSpecificPage,\n    onSelectAddress,\n    error,\n    setError,\n    defaultAddressesPerPage\n  } = useAddressScreens();\n\n  const addressesPerPage =\n    configuredAddressesPerPage ?? defaultAddressesPerPage;\n\n  const [version, setVersion] = useState('');\n  const [contractDataEnabled, setContractDataEnabled] = useState(false);\n\n  const dispatchLoginActions = ({\n    address,\n    index,\n    signature\n  }: {\n    address: string;\n    index: number;\n    signature?: string;\n  }) => {\n    dispatch(setLedgerLogin({ index, loginType: LoginMethodsEnum.ledger }));\n\n    if (signature) {\n      loginService.setTokenLoginInfo({ signature, address });\n    }\n\n    dispatch(loginAction({ address, loginMethod: LoginMethodsEnum.ledger }));\n\n    optionalRedirect({\n      callbackRoute,\n      onLoginRedirect,\n      options: { address, signature }\n    });\n  };\n\n  const onLoginFailed = (err: any, customMessage = '') => {\n    // Show errors only if the user initiated the login process (isLoading is true)\n    if (isLoading) {\n      const { errorMessage, defaultErrorMessage } = getLedgerErrorCodes(err);\n\n      const message =\n        errorMessage ?? defaultErrorMessage ?? failInitializeErrorText;\n\n      setError(`${message}.${customMessage}`);\n      setIsLoading(false);\n      dispatch(setLedgerAccount(null));\n    }\n  };\n\n  const isHWProviderInitialized = async () => {\n    try {\n      if (hwProvider instanceof HWProvider && hwProvider.isInitialized()) {\n        return hwProvider.isConnected();\n      }\n    } catch (e) {\n      onLoginFailed(e);\n    }\n\n    return false;\n  };\n\n  const initHWProvider = async () => {\n    const isInitialized = await isHWProviderInitialized();\n\n    if (isInitialized) {\n      setError('');\n      setIsLoading(false);\n      return;\n    }\n\n    try {\n      const hwWalletP = new HWProvider();\n      const initialized = await hwWalletP.init();\n\n      if (initialized) {\n        setAccountProvider(hwWalletP);\n      }\n\n      setError('');\n      setIsLoading(false);\n    } catch (e) {\n      onLoginFailed(e);\n    }\n  };\n\n  const loginUser = async () => {\n    const isInitialized = await isHWProviderInitialized();\n\n    if (!selectedAddress || !isInitialized) {\n      return onLoginFailed(failInitializeErrorText);\n    }\n\n    const { index } = selectedAddress;\n\n    if (hasNativeAuth && !token) {\n      token = await loginService.getNativeAuthLoginToken();\n      // Fetching block failed\n      if (!token) {\n        console.warn('Fetching block failed. Login cancelled.');\n        return;\n      }\n    }\n\n    if (token) {\n      loginService.setLoginToken(token);\n\n      try {\n        const loginInfo = await hwProvider.tokenLogin({\n          token: Buffer.from(`${token}{}`),\n          addressIndex: index\n        });\n\n        dispatchLoginActions({\n          address: loginInfo.address,\n          index,\n          signature: loginInfo.signature.toString('hex')\n        });\n      } catch (err) {\n        onLoginFailed(err, '. Update MultiversX App to continue.');\n      }\n    } else {\n      try {\n        const { address } = await hwProvider.login({ addressIndex: index });\n\n        dispatchLoginActions({\n          address,\n          index\n        });\n      } catch (err) {\n        onLoginFailed(err);\n\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  const onConfirmSelectedAddress = async () => {\n    try {\n      setIsLoading(true);\n\n      if (selectedAddress == null) {\n        return false;\n      }\n\n      if (ledgerAccount) {\n        dispatch(updateLedgerAccount(selectedAddress));\n      } else {\n        dispatch(\n          setLedgerAccount({\n            ...selectedAddress,\n            version,\n            hasContractDataEnabled: contractDataEnabled\n          })\n        );\n      }\n\n      setIsLoading(false);\n      await loginUser();\n    } catch (err) {\n      onLoginFailed(err);\n    }\n\n    setShowAddressList(false);\n\n    return true;\n  };\n\n  const fetchAccounts = async () => {\n    const isInitialized = await isHWProviderInitialized();\n\n    if (!isInitialized) {\n      return onLoginFailed(error);\n    }\n\n    try {\n      setIsLoading(true);\n\n      const accounts = await hwProvider.getAccounts(\n        startIndex,\n        addressesPerPage\n      );\n\n      const ledgerData = await getLedgerConfiguration(hwProvider);\n      setVersion(ledgerData.version);\n      setContractDataEnabled(ledgerData.dataEnabled);\n      setAccounts(accounts);\n      setIsLoading(false);\n    } catch (err) {\n      onLoginFailed(err);\n    }\n  };\n\n  const onStartLogin = async () => {\n    if (isLoggedIn) {\n      throw new Error(SECOND_LOGIN_ATTEMPT_ERROR);\n    }\n\n    clearInitiatedLogins();\n    setError('');\n\n    try {\n      setIsLoading(true);\n      const isInitialized = await isHWProviderInitialized();\n\n      if (!isInitialized) {\n        return onLoginFailed(failInitializeErrorText);\n      }\n\n      if (ledgerAccount != null) {\n        if (!selectedAddress) {\n          return onLoginFailed(failInitializeErrorText);\n        }\n\n        const { address } = await hwProvider.login({\n          addressIndex: selectedAddress.index.valueOf()\n        });\n\n        if (!address) {\n          return onLoginFailed('Login cancelled.');\n        }\n\n        dispatch(\n          loginAction({ address, loginMethod: LoginMethodsEnum.ledger })\n        );\n\n        optionalRedirect({\n          callbackRoute,\n          onLoginRedirect\n        });\n      } else {\n        if (!accounts?.length) {\n          await fetchAccounts();\n        }\n\n        setShowAddressList(true);\n      }\n\n      setIsLoading(false);\n    } catch (err) {\n      onLoginFailed(err);\n    }\n  };\n\n  // Need to initialise the HWProvider before starting the login process\n  // and fetch the accounts immediately afterward only once or if the address page changes\n  const initProviderAndAccounts = async () => {\n    try {\n      let isInitialized = await isHWProviderInitialized();\n\n      if (!isInitialized) {\n        await initHWProvider();\n      }\n\n      isInitialized = await isHWProviderInitialized();\n\n      if (!isInitialized) {\n        return onLoginFailed(failInitializeErrorText);\n      }\n\n      if (accounts.length === 0 || startIndex >= 0) {\n        await fetchAccounts();\n      }\n    } catch (err) {\n      onLoginFailed(err);\n    }\n  };\n\n  useEffect(() => {\n    initProviderAndAccounts();\n  }, [startIndex, showAddressList, hwProvider]);\n\n  useEffect(() => {\n    const shouldShowAddressList = accounts?.length > 0 && !showAddressList;\n\n    if (shouldShowAddressList) {\n      setShowAddressList(true);\n    }\n  }, [accounts]);\n\n  const loginFailed = Boolean(error);\n\n  return [\n    onStartLogin,\n    {\n      loginFailed,\n      isLoggedIn: isLoggedIn && !loginFailed,\n      error,\n      isLoading: isLoading && !loginFailed\n    },\n    {\n      accounts,\n      showAddressList,\n      startIndex,\n      selectedAddress,\n      version,\n      contractDataEnabled,\n      onGoToPrevPage,\n      onGoToNextPage,\n      onGoToSpecificPage,\n      onSelectAddress,\n      onConfirmSelectedAddress\n    }\n  ];\n};\n"],
  "mappings": "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",
  "names": []
}
