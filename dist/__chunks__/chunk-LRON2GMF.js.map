{
  "version": 3,
  "sources": ["../../src/reduxStore/slices/transactionsSlice.ts"],
  "sourcesContent": ["import { createSlice, PayloadAction } from '@reduxjs/toolkit';\nimport { REHYDRATE } from 'redux-persist';\nimport {\n  CustomTransactionInformation,\n  ServerTransactionType,\n  SignedTransactionsBodyType,\n  SignedTransactionsType,\n  SignedTransactionType,\n  TransactionsToSignType\n} from 'types';\nimport {\n  TransactionBatchStatusesEnum,\n  TransactionServerStatusesEnum\n} from 'types/enums.types';\nimport {\n  getIsTransactionFailed,\n  getIsTransactionNotExecuted,\n  getIsTransactionSuccessful\n} from 'utils/transactions/transactionStateByStatus';\nimport { logoutAction } from '../commonActions';\n\nexport interface UpdateSignedTransactionsPayloadType {\n  sessionId: string;\n  status: TransactionBatchStatusesEnum;\n  errorMessage?: string;\n  transactions?: SignedTransactionType[];\n  customTransactionInformationOverrides?: Partial<CustomTransactionInformation>;\n}\n\nexport interface MoveTransactionsToSignedStatePayloadType\n  extends SignedTransactionsBodyType {\n  sessionId: string;\n  customTransactionInformation?: CustomTransactionInformation;\n}\n\nexport interface UpdateSignedTransactionStatusPayloadType {\n  sessionId: string;\n  transactionHash: string;\n  status: TransactionServerStatusesEnum;\n  serverTransaction?: ServerTransactionType;\n  errorMessage?: string;\n  inTransit?: boolean;\n}\n\nexport interface TransactionsSliceStateType {\n  signedTransactions: SignedTransactionsType;\n  transactionsToSign: TransactionsToSignType | null;\n  signTransactionsError: string | null;\n  signTransactionsCancelMessage: string | null;\n  customTransactionInformationForSessionId: {\n    [sessionId: string]: CustomTransactionInformation;\n  };\n}\n\nconst initialState: TransactionsSliceStateType = {\n  signedTransactions: {},\n  transactionsToSign: null,\n  signTransactionsError: null,\n  signTransactionsCancelMessage: null,\n  customTransactionInformationForSessionId: {}\n};\n\nconst defaultCustomInformation: CustomTransactionInformation = {\n  signWithoutSending: false,\n  sessionInformation: null,\n  redirectAfterSign: false\n};\n\nexport const transactionsSlice = createSlice({\n  name: 'transactionsSlice',\n  initialState,\n  reducers: {\n    moveTransactionsToSignedState: (\n      state: TransactionsSliceStateType,\n      action: PayloadAction<MoveTransactionsToSignedStatePayloadType>\n    ) => {\n      const {\n        sessionId,\n        transactions,\n        errorMessage,\n        status,\n        redirectRoute,\n        customTransactionInformation: overrideCustomTransactionInformation\n      } = action.payload;\n\n      state.customTransactionInformationForSessionId[sessionId] = {\n        ...defaultCustomInformation,\n        ...(state.signedTransactions[sessionId]?.customTransactionInformation ||\n          {}),\n        ...(state.customTransactionInformationForSessionId[sessionId] || {})\n      };\n\n      state.signedTransactions[sessionId] = {\n        transactions,\n        status,\n        errorMessage,\n        redirectRoute,\n        customTransactionInformation: {\n          ...state.customTransactionInformationForSessionId[sessionId],\n          ...(overrideCustomTransactionInformation ?? {})\n        }\n      };\n\n      if (state?.transactionsToSign?.sessionId === sessionId) {\n        state.transactionsToSign = initialState.transactionsToSign;\n      }\n    },\n\n    clearSignedTransaction: (\n      state: TransactionsSliceStateType,\n      action: PayloadAction<string>\n    ) => {\n      if (state.signedTransactions[action.payload]) {\n        delete state.signedTransactions[action.payload];\n      }\n    },\n    clearTransactionToSign: (state: TransactionsSliceStateType) => {\n      if (state?.transactionsToSign) {\n        state.transactionsToSign = null;\n      }\n    },\n    updateSignedTransaction: (\n      state: TransactionsSliceStateType,\n      action: PayloadAction<SignedTransactionsType>\n    ) => {\n      state.signedTransactions = {\n        ...state.signedTransactions,\n        ...action.payload\n      };\n    },\n    updateSignedTransactions: (\n      state: TransactionsSliceStateType,\n      action: PayloadAction<UpdateSignedTransactionsPayloadType>\n    ) => {\n      const { sessionId, status, errorMessage, transactions } = action.payload;\n      const session = state.signedTransactions[sessionId];\n      if (session != null) {\n        state.signedTransactions[sessionId].status = status;\n        if (errorMessage != null) {\n          state.signedTransactions[sessionId].errorMessage = errorMessage;\n        }\n        if (transactions != null) {\n          state.signedTransactions[sessionId].transactions = transactions;\n        }\n      }\n    },\n    updateSignedTransactionStatus: (\n      state: TransactionsSliceStateType,\n      action: PayloadAction<UpdateSignedTransactionStatusPayloadType>\n    ) => {\n      const {\n        sessionId,\n        status,\n        errorMessage,\n        transactionHash,\n        serverTransaction,\n        inTransit\n      } = action.payload;\n      const transactions = state.signedTransactions?.[sessionId]?.transactions;\n      if (transactions != null) {\n        state.signedTransactions[sessionId].transactions = transactions.map(\n          (transaction) => {\n            if (transaction.hash === transactionHash) {\n              return {\n                ...(serverTransaction ?? {}),\n                ...transaction,\n                status,\n                errorMessage,\n                inTransit\n              };\n            }\n            return transaction;\n          }\n        );\n        const areTransactionsSuccessful = state.signedTransactions[\n          sessionId\n        ]?.transactions?.every((transaction) => {\n          return getIsTransactionSuccessful(transaction.status);\n        });\n\n        const areTransactionsFailed = state.signedTransactions[\n          sessionId\n        ]?.transactions?.some((transaction) =>\n          getIsTransactionFailed(transaction.status)\n        );\n\n        const areTransactionsNotExecuted = state.signedTransactions[\n          sessionId\n        ]?.transactions?.every((transaction) =>\n          getIsTransactionNotExecuted(transaction.status)\n        );\n\n        if (areTransactionsSuccessful) {\n          state.signedTransactions[sessionId].status =\n            TransactionBatchStatusesEnum.success;\n        }\n        if (areTransactionsFailed) {\n          state.signedTransactions[sessionId].status =\n            TransactionBatchStatusesEnum.fail;\n        }\n        if (areTransactionsNotExecuted) {\n          state.signedTransactions[sessionId].status =\n            TransactionBatchStatusesEnum.invalid;\n        }\n      }\n    },\n    setTransactionsToSign: (\n      state: TransactionsSliceStateType,\n      action: PayloadAction<TransactionsToSignType>\n    ) => {\n      state.transactionsToSign = action.payload;\n\n      const { sessionId, customTransactionInformation } = action.payload;\n      state.customTransactionInformationForSessionId[sessionId] =\n        customTransactionInformation;\n\n      state.signTransactionsError = null;\n    },\n    clearAllTransactionsToSign: (state: TransactionsSliceStateType) => {\n      state.transactionsToSign = initialState.transactionsToSign;\n      state.signTransactionsError = null;\n    },\n    clearAllSignedTransactions: (state: TransactionsSliceStateType) => {\n      state.signedTransactions = initialState.signedTransactions;\n    },\n    setSignTransactionsError: (\n      state: TransactionsSliceStateType,\n      action: PayloadAction<string | null>\n    ) => {\n      state.signTransactionsError = action.payload;\n    },\n    setSignTransactionsCancelMessage: (\n      state: TransactionsSliceStateType,\n      action: PayloadAction<string | null>\n    ) => {\n      state.signTransactionsCancelMessage = action.payload;\n    },\n    updateSignedTransactionsCustomTransactionInformation: (\n      state: TransactionsSliceStateType,\n      action: PayloadAction<{\n        sessionId: string;\n        customTransactionInformationOverrides: Partial<CustomTransactionInformation>;\n      }>\n    ) => {\n      const { sessionId, customTransactionInformationOverrides } =\n        action.payload;\n      const session = state.signedTransactions[sessionId];\n      if (session != null) {\n        state.signedTransactions[sessionId].customTransactionInformation = {\n          ...(state.signedTransactions[sessionId]\n            .customTransactionInformation as CustomTransactionInformation),\n          ...customTransactionInformationOverrides\n        };\n      }\n    }\n  },\n  extraReducers: (builder) => {\n    builder.addCase(logoutAction, () => {\n      return initialState;\n    });\n    builder.addCase(REHYDRATE, (state, action: any) => {\n      // cancel message does not persist between page reloads\n      state.signTransactionsCancelMessage = null;\n\n      if (!action.payload?.transactions) {\n        return;\n      }\n\n      const { signedTransactions, customTransactionInformationForSessionId } =\n        action.payload.transactions;\n      const parsedSignedTransactions = Object.entries(\n        signedTransactions\n      ).reduce((acc, [sessionId, transaction]) => {\n        const txTimestamp: any = new Date(sessionId);\n        const expiration: any = new Date();\n        expiration.setHours(expiration.getHours() + 5);\n        const isExpired = expiration - txTimestamp > 0;\n        if (!isExpired) {\n          acc[sessionId] = transaction;\n        }\n        return acc;\n      }, {} as { [key: string]: any });\n      if (customTransactionInformationForSessionId != null) {\n        state.customTransactionInformationForSessionId =\n          customTransactionInformationForSessionId;\n      }\n      if (signedTransactions != null) {\n        state.signedTransactions = parsedSignedTransactions;\n      }\n    });\n  }\n});\n\nexport const {\n  updateSignedTransactionStatus,\n  updateSignedTransactions,\n  setTransactionsToSign,\n  clearAllTransactionsToSign,\n  clearAllSignedTransactions,\n  clearSignedTransaction,\n  clearTransactionToSign,\n  setSignTransactionsError,\n  setSignTransactionsCancelMessage,\n  moveTransactionsToSignedState,\n  updateSignedTransactionsCustomTransactionInformation\n} = transactionsSlice.actions;\n\nexport default transactionsSlice.reducer;\n"],
  "mappings": "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",
  "names": []
}
