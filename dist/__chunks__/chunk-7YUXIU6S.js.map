{
  "version": 3,
  "sources": ["../../src/hooks/signMessage/useSignMessage.ts"],
  "sourcesContent": ["import { useEffect, useState } from 'react';\nimport { Address, Message } from '@multiversx/sdk-core';\nimport {\n  CANCELLED,\n  ERROR_SIGNING,\n  PROVIDER_NOT_INITIALIZED\n} from 'constants/index';\nimport { useGetAccountProvider } from 'hooks/account/useGetAccountProvider';\nimport { useDispatch, useSelector } from 'reduxStore/DappProviderContext';\nimport {\n  lastSignedSessionId,\n  signedMessageInfoSliceSelector\n} from 'reduxStore/selectors';\nimport {\n  clearSignedMessageInfo,\n  setSignSession,\n  setSignSessionState,\n  setSignTransactionsCancelMessage\n} from 'reduxStore/slices';\nimport {\n  LoginMethodsEnum,\n  SignedMessageQueryParamsEnum,\n  SignedMessageStatusesEnum\n} from 'types';\nimport {\n  signMessage as signMessageWithProvider,\n  SignMessageType\n} from 'utils/account/signMessage';\nimport { parseNavigationParams } from 'utils/parseNavigationParams';\nimport { getWindowLocation } from 'utils/window/getWindowLocation';\nimport {\n  addOriginToLocationPath,\n  getAccountProvider,\n  getAddress,\n  removeSearchParamsFromUrl\n} from '../../utils';\nimport { useGetSignMessageInfoStatus } from './useGetSignedMessageStatus';\n\nexport interface CancelPropsType {\n  callbackRoute?: string;\n  errorMessage: string;\n}\n\nexport interface SignedMessageParamsType {\n  status: SignedMessageStatusesEnum;\n  signature: string;\n}\n\n/**\n * Used to sign message with providers\n * 1. Signing simply from dapp without redirect (with providers)\n * 2. Signing from dapp logged in with web wallet (redirect to web wallet)\n * 3. Signing from web wallet as hook after redirect and replying back with signature\n */\nexport const useSignMessage = (options?: { hasConsentPopup?: boolean }) => {\n  const dispatch = useDispatch();\n  const [currentSessionId, setCurrentSessionId] = useState<string>('');\n  const signedMessageInfo = useSelector(signedMessageInfoSliceSelector);\n  const currentSession = signedMessageInfo.signedSessions[currentSessionId];\n  const { isPending, errorMessage } = useGetSignMessageInfoStatus();\n  const { search, origin } = getWindowLocation();\n  const { provider, providerType } = useGetAccountProvider();\n  const isWalletLogin = providerType === LoginMethodsEnum.wallet;\n  const lastSignSession = useSelector(lastSignedSessionId);\n\n  // Clears the state\n  const onAbort = () => {\n    dispatch(clearSignedMessageInfo());\n    return removeSearchParamsFromUrl({\n      removeParams: Object.keys(SignedMessageQueryParamsEnum)\n    });\n  };\n\n  // Cancel signing\n  const onCancel = ({\n    callbackRoute,\n    errorMessage = CANCELLED\n  }: CancelPropsType) => {\n    const isCancelled = errorMessage.includes(CANCELLED);\n    const sessionId = Date.now().toString();\n\n    if (!currentSession) {\n      setCurrentSessionId(sessionId);\n    }\n\n    dispatch(\n      setSignSession({\n        errorMessage,\n        sessionId,\n        signedSession: {\n          callbackUrl: callbackRoute,\n          status: isCancelled\n            ? SignedMessageStatusesEnum.cancelled\n            : SignedMessageStatusesEnum.failed\n        }\n      })\n    );\n    dispatch(setSignTransactionsCancelMessage(errorMessage));\n  };\n\n  const checkCallbackSessionId = (\n    callbackRoute: string | undefined,\n    sessionId: string\n  ) => {\n    if (!callbackRoute) {\n      return '';\n    }\n\n    const callbackUrl = new URL(addOriginToLocationPath(callbackRoute));\n\n    // Make sure callbackURL has sessionId\n    if (!callbackUrl.searchParams.get(SignedMessageQueryParamsEnum.sessionId)) {\n      callbackUrl.searchParams.append(\n        SignedMessageQueryParamsEnum.sessionId,\n        sessionId\n      );\n    }\n\n    return `${isWalletLogin ? origin : ''}${callbackUrl.pathname}${\n      callbackUrl.search\n    }${callbackUrl.hash}`;\n  };\n\n  const checkProviderIsInitialized = async () => {\n    if (isWalletLogin) {\n      return;\n    }\n\n    const isProviderInitialized = await provider?.init?.();\n\n    if (!isProviderInitialized) {\n      return;\n    }\n\n    return isProviderInitialized;\n  };\n\n  const signMessageWithWallet = async ({\n    message,\n    callbackRoute\n  }: SignMessageType) => {\n    const address = await getAddress();\n    const provider = getAccountProvider();\n    const callbackUrl = encodeURIComponent(String(callbackRoute));\n\n    const signableMessage = new Message({\n      address: new Address(address),\n      data: Buffer.from(message)\n    });\n\n    return provider.signMessage(signableMessage, {\n      callbackUrl\n    });\n  };\n\n  const signMessage = async (props: SignMessageType) => {\n    const sessionId = Date.now().toString();\n    setCurrentSessionId(sessionId);\n\n    const callbackRoute = checkCallbackSessionId(\n      props.callbackRoute,\n      sessionId\n    );\n\n    dispatch(\n      setSignSession({\n        sessionId,\n        signedSession: {\n          status: SignedMessageStatusesEnum.pending,\n          message: props.message,\n          callbackUrl: callbackRoute\n        }\n      })\n    );\n\n    if (isWalletLogin) {\n      return signMessageWithWallet({\n        ...props,\n        callbackRoute\n      });\n    }\n\n    try {\n      await checkProviderIsInitialized();\n    } catch (error) {\n      const errorMessage =\n        (error as Error)?.message ||\n        (error as string) ||\n        PROVIDER_NOT_INITIALIZED;\n\n      console.error(errorMessage);\n\n      onCancel({\n        errorMessage: PROVIDER_NOT_INITIALIZED,\n        callbackRoute\n      });\n\n      return null;\n    }\n\n    try {\n      const signedMessage = await signMessageWithProvider({\n        ...props,\n        callbackRoute,\n        options\n      });\n\n      if (signedMessage?.signature) {\n        dispatch(\n          setSignSession({\n            sessionId,\n            signedSession: {\n              status: SignedMessageStatusesEnum.signed,\n              callbackUrl: callbackRoute,\n              message: props.message,\n              signature: Buffer.from(signedMessage?.signature).toString('hex')\n            }\n          })\n        );\n\n        return signedMessage;\n      }\n\n      onCancel({\n        errorMessage: CANCELLED,\n        callbackRoute\n      });\n    } catch (error) {\n      const errorMessage =\n        (error as Error)?.message || (error as string) || ERROR_SIGNING;\n      console.error(errorMessage);\n\n      onCancel({\n        errorMessage: ERROR_SIGNING,\n        callbackRoute\n      });\n    }\n\n    return null;\n  };\n\n  /**\n   * Used for getting signed message info from query params\n   * 1. Parse query params on hook redirect from dapp to web wallet\n   * 2. Parse query params on hook reply back to dapp from web wallet\n   */\n  const parseSignedMessageFromUrl = () => {\n    if (search) {\n      const {\n        remainingParams: { signature, sessionId, status },\n        clearNavigationHistory\n      } = parseNavigationParams(Object.values(SignedMessageQueryParamsEnum));\n\n      if (!sessionId) {\n        return;\n      }\n\n      setCurrentSessionId(sessionId);\n\n      if (\n        [\n          SignedMessageStatusesEnum.cancelled,\n          SignedMessageStatusesEnum.failed\n        ].includes(status as SignedMessageStatusesEnum)\n      ) {\n        // Failed to sign message\n        onCancel({\n          errorMessage:\n            status === SignedMessageStatusesEnum.cancelled\n              ? CANCELLED\n              : ERROR_SIGNING\n        });\n      }\n\n      if (signature && status === SignedMessageStatusesEnum.signed) {\n        // Message was signed successfully\n        dispatch(\n          setSignSession({\n            sessionId,\n            signedSession: {\n              signature,\n              status\n            }\n          })\n        );\n      }\n\n      clearNavigationHistory();\n    }\n  };\n\n  // Parse the signed message info from URL (after callback was triggered from provider)\n  useEffect(() => {\n    parseSignedMessageFromUrl();\n  }, [search]);\n\n  // Reply to the dapp when message was signed, cancel, or failed\n  useEffect(() => {\n    // Reset isSigning state\n    if ((isPending || errorMessage) && !currentSession) {\n      dispatch(setSignSessionState({ isSigning: false, errorMessage: '' }));\n    }\n  }, []);\n\n  // Clear state when session is not found\n  useEffect(() => {\n    if (currentSessionId && !currentSession && !isPending) {\n      dispatch(setSignSessionState({ isSigning: false, errorMessage: '' }));\n    }\n  }, [currentSessionId]);\n\n  return {\n    onAbort,\n    onCancel,\n    signMessage,\n    sessionId: currentSessionId || lastSignSession\n  };\n};\n"],
  "mappings": "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",
  "names": []
}
